<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>金礼秋的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-08T08:46:03.114Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>金礼秋</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>利用nginx来处理前端跨域请求</title>
    <link href="http://yoursite.com/2019/04/08/%E5%88%A9%E7%94%A8nginx%E6%9D%A5%E5%A4%84%E7%90%86%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82/"/>
    <id>http://yoursite.com/2019/04/08/利用nginx来处理前端跨域请求/</id>
    <published>2019-04-08T07:39:25.000Z</published>
    <updated>2019-04-08T08:46:03.114Z</updated>
    
    <content type="html"><![CDATA[<p>9102年的前端, 浏览器跨域访问限制的问题不用多说了.常用的解决方案无非jsonp, 服务端设置cros允许跨域, iframe, 代理服务转发等等. 这里使用nginx来进行转发, 所以cros相关配置要写入nginx配置</p><h4 id="问题场景"><a href="#问题场景" class="headerlink" title="问题场景"></a>问题场景</h4><p>前端业务主要应用在webview中, 由客户端根据离线包更新机制决定什么时候访问线上资源, 什么时候下载更新使用离线资源. 因为jsonp只能发送get请求且无法携带cookie, 所以pass. 有现成的基于node和php的代理中转服务, 但是链路太长, 且错误返回不可控, 所以使用nginx作为代理服务转发请求到服务端. 线上接口请求通过nginx代理转发, 都在同域名下, 所以是ok的. 但是离线资源因为是在本地, 所以协议头为<code>file://</code>, 如此一来就发生跨域了. 根据观察发现在跨域时只发送了options, 返回204. 后续的post请求没有发送.</p><h4 id="options请求"><a href="#options请求" class="headerlink" title="options请求"></a>options请求</h4><p>当发生复杂跨域请求时, 浏览器会发送预检请求给服务端, 即method为options的http请求来判断是否安全. 何为复杂请求? 即对应的非简单请求. 大致简单请求列一下有这些:</p><ul><li>方法为<code>GET</code>, <code>HEAD</code>, <code>POST</code></li><li>请求头中无自定义头, <code>Content-Type</code>为<code>text/plain</code>, <code>multipart/form-data</code>, <code>application/x-www-form-urlencoded</code><br>除此之外, 可认定为复杂请求</li></ul><h4 id="服务端cros配置"><a href="#服务端cros配置" class="headerlink" title="服务端cros配置"></a>服务端cros配置</h4><ul><li><code>Access-Control-Allow-Origin</code>: 允许跨域的host, 除此之外其他来源的站点皆为不可信. 当设置为<code>*</code>时代表允许所有来访的站点跨域获取数据</li><li><code>Access-Control-Allow-Methods</code>: 允许跨域获取数据的请求方式, 除指定的methods外皆为不可信</li><li><code>Access-Control-Allow-Headers</code>: 允许携带的请求头字段</li><li><code>Access-Control-Allow-Credentials</code>: 是否允许后续请求携带认证信息（cookies）,该值只能是true,否则不返回</li><li><code>Access-Control-Max-Age</code>: 预检结果缓存时间</li></ul><h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><p>既然发送了options请求, 那么可以断定是客户端通过离线资源来访问页面发生了跨域. 预检请求发送过去后, 后续的post请求没有跟上, 则说明请求未通过服务端设置的校验规则. 我们来看一下nginx的配置如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">if ($request_method = &apos;OPTIONS&apos;) &#123;</div><div class="line">return 204;</div><div class="line">&#125;</div><div class="line"></div><div class="line">add_header Access-Control-Allow-Origin &apos;*&apos;;</div><div class="line">add_header Access-Control-Allow-Methods &apos;GET, POST, OPTIONS&apos;;</div><div class="line">add_header Access-Control-Allow-Headers &apos;Applicant-Type,DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range&apos;;</div></pre></td></tr></table></figure></p><p>看上去没有问题, 而且headers允许携带的字段也很全面. 于是通过抓包分析, 发现请求头中有个叫<code>gToken</code>的自定义参数, 那么问题很明显了, 就是因为请求头中携带了nginx中未允许的字段, 所以导致该请求不授信. 于是在<code>Access-Control-Allow-Headers</code>中添加<code>gtoken</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">add_header Access-Control-Allow-Headers &apos;Applicant-Type,DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range,gToken&apos;;</div></pre></td></tr></table></figure></p><p>再次请求则访问成功.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;9102年的前端, 浏览器跨域访问限制的问题不用多说了.常用的解决方案无非jsonp, 服务端设置cros允许跨域, iframe, 代理服务转发等等. 这里使用nginx来进行转发, 所以cros相关配置要写入nginx配置&lt;/p&gt;
&lt;h4 id=&quot;问题场景&quot;&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
      <category term="cros" scheme="http://yoursite.com/tags/cros/"/>
    
      <category term="问题记录" scheme="http://yoursite.com/tags/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>video标签事件指北</title>
    <link href="http://yoursite.com/2018/07/24/video%E6%A0%87%E7%AD%BE%E4%BA%8B%E4%BB%B6%E6%8C%87%E5%8C%97/"/>
    <id>http://yoursite.com/2018/07/24/video标签事件指北/</id>
    <published>2018-07-24T13:35:57.000Z</published>
    <updated>2018-07-24T14:19:22.338Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近一直在维护一个短视频项目的移动web端,主要功能就是用自定义的播放器点播一个视频.目前市面上没有找到类似的UI,所以基于360奇舞团的chimee写了些UI插件.其中关于播放控制及状态管理的插件踩了不少坑,主要原因就是对video标签的事件流相对陌生,所以这里记录一下.</p><h1 id="video标签事件"><a href="#video标签事件" class="headerlink" title="video标签事件"></a>video标签事件</h1><table><thead><tr><th style="text-align:left">事件</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">loadstart</td><td style="text-align:left">浏览器开始在网上寻找媒体数据</td></tr><tr><td style="text-align:left">progress</td><td style="text-align:left">浏览器正在获取媒体数据</td></tr><tr><td style="text-align:left">suspend</td><td style="text-align:left">浏览器暂停获取媒体数据，但是下载过程并滑正常结束</td></tr><tr><td style="text-align:left">abort</td><td style="text-align:left">浏览器在下载完全部媒体数据之前中止获取媒体数据，但是并不是由错误引起的</td></tr><tr><td style="text-align:left">error</td><td style="text-align:left">获取媒体数据过程中出错</td></tr><tr><td style="text-align:left">emptied</td><td style="text-align:left">video元素或audio元素所在网络突然变为未初始化状态可能原因有两个: 1.载入媒体过程中突然发生一个致命错误 2.在浏览器正在选择支持的播放格式时，又调用 了load方法重新载入媒体</td></tr><tr><td style="text-align:left">stalled</td><td style="text-align:left">浏览器尝试获取媒体数据失败</td></tr><tr><td style="text-align:left">play</td><td style="text-align:left">即将开始播放，当执行了play方法时触发，或数据下载后元素被设为autoplay属性</td></tr><tr><td style="text-align:left">pause</td><td style="text-align:left">播放暂停，当执行了pause方式时触发</td></tr><tr><td style="text-align:left">loadedmetadata</td><td style="text-align:left">浏览器获取完毕媒体的时间长和字节数</td></tr><tr><td style="text-align:left">loaded</td><td style="text-align:left">浏览器加载当前帧结束</td></tr><tr><td style="text-align:left">waiting</td><td style="text-align:left">播放过程由于得不到下一帧而暂停播放（例如下一帧尚未加载完毕），但很快就能够得到下一帧</td></tr><tr><td style="text-align:left">canplay</td><td style="text-align:left">浏览器能够播放媒体，但估计以当前的播放速率不能直接播放完毕，播放期间需要缓冲</td></tr><tr><td style="text-align:left">canplaythrough</td><td style="text-align:left">浏览器能够播放媒体，而且以当前播放速率能够将媒体播放完毕，不再需要进行缓冲</td></tr><tr><td style="text-align:left">seeking</td><td style="text-align:left">seeking属性变为true，浏览器正在请求数据</td></tr><tr><td style="text-align:left">seeked</td><td style="text-align:left">seeking属性变为false，浏览器停止请求数据</td></tr><tr><td style="text-align:left">timeupdate</td><td style="text-align:left">由于播放位置被改变，可能是播放过程中的自然改变，也可能是被人为的改变，或由于播放不能连续而发生的跳变</td></tr><tr><td style="text-align:left">ended</td><td style="text-align:left">播放结束后停止播放</td></tr><tr><td style="text-align:left">ratechange</td><td style="text-align:left">defaultplaybackRate属性（默认播放速率）或playbackRate属性（当前播放速率）被改变</td></tr><tr><td style="text-align:left">druationchange</td><td style="text-align:left">播放时长被改变</td></tr><tr><td style="text-align:left">volumechange</td><td style="text-align:left">volume属性（音量）被改变或muted属性（静音状态）被改变</td></tr></tbody></table><p>以上为目前网上搜索到的video相关事件的列表.</p><p>写个demo依次调用:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> video = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'video'</span>)[<span class="number">0</span>];</div><div class="line"></div><div class="line">video.addEventListener(<span class="string">'loadstart'</span>, () =&gt; &#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'loadstart'</span>)</div><div class="line">&#125;)</div><div class="line">video.addEventListener(<span class="string">'error'</span>, () =&gt; &#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'error'</span>)</div><div class="line">&#125;)</div><div class="line">video.addEventListener(<span class="string">'suspend'</span>, () =&gt; &#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'suspend'</span>)</div><div class="line">&#125;)</div><div class="line">video.addEventListener(<span class="string">'emptied'</span>, () =&gt; &#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'emptied'</span>)</div><div class="line">&#125;)</div><div class="line">video.addEventListener(<span class="string">'durationchange'</span>, () =&gt; &#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'durationchange'</span>)</div><div class="line">&#125;)</div><div class="line">video.addEventListener(<span class="string">'loadedmetadata'</span>, () =&gt; &#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'loadedmetadata'</span>)</div><div class="line">&#125;)</div><div class="line">video.addEventListener(<span class="string">'loadeddata'</span>, () =&gt; &#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'loadeddata'</span>)</div><div class="line">&#125;)</div><div class="line">video.addEventListener(<span class="string">'abort'</span>, () =&gt; &#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'abort'</span>)</div><div class="line">&#125;)</div><div class="line">video.addEventListener(<span class="string">'play'</span>, () =&gt; &#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'play'</span>)</div><div class="line">&#125;)</div><div class="line">video.addEventListener(<span class="string">'pause'</span>, () =&gt; &#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'pause'</span>)</div><div class="line">&#125;)</div><div class="line">video.addEventListener(<span class="string">'canplay'</span>, () =&gt; &#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'canplay'</span>)</div><div class="line">&#125;)</div><div class="line">video.addEventListener(<span class="string">'canplaythrough'</span>, () =&gt; &#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'canplaythrough'</span>)</div><div class="line">&#125;)</div><div class="line">video.addEventListener(<span class="string">'timeupdate'</span>, () =&gt; &#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'timeupdate'</span>)</div><div class="line">&#125;)</div><div class="line">video.addEventListener(<span class="string">'progress'</span>, () =&gt; &#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'progress'</span>)</div><div class="line">&#125;)</div><div class="line">video.addEventListener(<span class="string">'stalled'</span>, () =&gt; &#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'stalled'</span>)</div><div class="line">&#125;)</div><div class="line">video.addEventListener(<span class="string">'seeking'</span>, () =&gt; &#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'seeking'</span>)</div><div class="line">&#125;)</div><div class="line">video.addEventListener(<span class="string">'seeked'</span>, () =&gt; &#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'seeked'</span>)</div><div class="line">&#125;)</div><div class="line">video.addEventListener(<span class="string">'waiting'</span>, () =&gt; &#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'waiting'</span>)</div><div class="line">&#125;)</div><div class="line">video.addEventListener(<span class="string">'ratechange'</span>, () =&gt; &#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'ratechange'</span>)</div><div class="line">&#125;)</div><div class="line">video.addEventListener(<span class="string">'druationchange'</span>, () =&gt; &#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'druationchange'</span>)</div><div class="line">&#125;)</div><div class="line">video.addEventListener(<span class="string">'volumechange'</span>, () =&gt; &#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'volumechange'</span>)</div><div class="line">&#125;)</div><div class="line">video.addEventListener(<span class="string">'ended'</span>, () =&gt; &#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'ended'</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><h1 id="视频初始化"><a href="#视频初始化" class="headerlink" title="视频初始化"></a>视频初始化</h1><p>页面渲染完毕, video标签通过src引入媒体资源, 进行一系列初始化操作.这个过程中我们还没有对视频进行播放操作,其流程如下: </p><img src="/2018/07/24/video标签事件指北/initProcess.png" alt="initProcess.png" title=""><p>这里要注意,canplaythrough只是预计不会在播放过程中发生缓冲,实际过程中并不能保证.我就遇到了只播放零点几秒就继续缓冲的情况.<br>关于请求媒体资源时206状态码的相关问题可以看我之前的文章:<a href="/2017/10/25/audio-and-206/">audio标签与206状态码</a></p><h1 id="播放视频"><a href="#播放视频" class="headerlink" title="播放视频"></a>播放视频</h1><p>接下来我们点击视频播放按钮,播放一段时间后点击暂停,其输出结果如下:</p><img src="/2018/07/24/video标签事件指北/output1.png" alt="output1.png" title=""><p>首先触发<code>play</code>事件,然后<code>timeupdate</code>事件和<code>progress</code>事件互相交替不断触发.这里需要注意,当视频以缓冲内容播放完时,<code>timeupdate</code>事件就会停止触发,等待<code>progress</code>不断获取一定量的时候才会继续进行,这就是我们常见的视频的loading状态按理应该也在此阶段触发.因为这方面经验不足,所以处理方法不知是否得当,我是通过<code>progress</code>传入的当前event的<code>buffered</code>来进行判断.<code>buffered</code>为以缓冲的媒体片段,通过获取的最后一个片段的结尾位置和当前视频的<code>currentTime</code>进行比对来决定是否需要展示loading.(如果有更好的方法欢迎提出).<br>期间<code>canplaythrough</code>又有触发,说明其不是在初始化时执行一次就不再执行了,这里需要注意.<br>最后点击暂停按钮触发<code>pause</code>事件,且<code>progress</code>事件不再触发.</p><h1 id="跳转至为缓冲区域"><a href="#跳转至为缓冲区域" class="headerlink" title="跳转至为缓冲区域"></a>跳转至为缓冲区域</h1><img src="/2018/07/24/video标签事件指北/video1.png" alt="video1.png" title=""><p>如图所示,红框位置为播放器未缓冲区域,我们可以观察跳转至未缓冲区域时的事件触发状况.<br>触发流程如下:<br><img src="/2018/07/24/video标签事件指北/output2.png" alt="output2.png" title=""><br><code>seeking</code>代表用户目前跳转了进度,浏览器正在寻址中.并且开始缓冲后续片段,然后触发了<code>timeupdate</code>,代表已经更新了当前的时间,这时候才<code>seeked</code>,寻址结束.并且<code>canplay</code>和<code>canplaythrough</code>再次触发</p><h1 id="跳转至以缓冲区域"><a href="#跳转至以缓冲区域" class="headerlink" title="跳转至以缓冲区域"></a>跳转至以缓冲区域</h1><img src="/2018/07/24/video标签事件指北/video2.png" alt="video2.png" title=""><img src="/2018/07/24/video标签事件指北/output3.png" alt="output3.png" title=""><p>跳转,然后直接<code>timeupdate</code>,跳转结束,视频可以播放.接着再次触发<code>progress</code>发起请求来确认后续内容,最后<code>canplaythrough</code>.</p><h1 id="拖动进度条"><a href="#拖动进度条" class="headerlink" title="拖动进度条"></a>拖动进度条</h1><p>我们拖动进度条快速的滑动但不具体的停止在某个点上,其表现为不停的触发<code>seeking</code>,说明在不停的寻址.当我们悬停在某个位置上但却没有松开按键,<code>progress</code>触发,<code>然后timeupdate</code> -&gt; <code>seeked</code> -&gt; <code>canplay</code> -&gt; <code>canplaythrough</code>.此过程中画面已经切换到对应时间的那一帧.</p><h1 id="播放结束"><a href="#播放结束" class="headerlink" title="播放结束"></a>播放结束</h1><p>最后视频播放结束时先触发了pause然后ended.</p><p>以上就是对于video标签播放时的事件流触发的梳理,如有遗漏或错误欢迎指正.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近一直在维护一个短视频项目的移动web端,主要功能就是用自定义的播放器点播一个视频.目前市面上没有找到类似的UI,所以基于360奇舞团的c
      
    
    </summary>
    
    
      <category term="video" scheme="http://yoursite.com/tags/video/"/>
    
  </entry>
  
  <entry>
    <title>vuex的commit和dispatch方法实现</title>
    <link href="http://yoursite.com/2018/04/29/vuex%E7%9A%84commit%E5%92%8Cdispatch%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2018/04/29/vuex的commit和dispatch方法实现/</id>
    <published>2018-04-29T05:47:48.000Z</published>
    <updated>2018-04-29T08:03:14.581Z</updated>
    
    <content type="html"><![CDATA[<p>当我们配置好vuex并生成实例后,就可以开始玩耍了.观看vuex的文档的话你应该会知道如何修改state里的数据,即在mutions中定义方法去修改state,而外部通过store暴露出的commit方法来调用mutations中的方法.除了可以在外部使用外,在action中执行完了异步操作我们也是通过commit方法来调用mution提交state的修改.所以接下来我们看一下commit的实现.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//type: mutions中的方法名,payload为mutions中方法的传参</span></div><div class="line">commit (_type, _payload, _options) &#123;</div><div class="line">    <span class="comment">// 将传入的type,payload,options转换成统一格式</span></div><div class="line">    <span class="keyword">const</span> &#123;</div><div class="line">      type,</div><div class="line">      payload,</div><div class="line">      options</div><div class="line">    &#125; = unifyObjectStyle(_type, _payload, _options)</div><div class="line"></div><div class="line">    <span class="keyword">const</span> mutation = &#123; type, payload &#125;</div><div class="line"><span class="comment">//从_mutations中获取对应type的方法</span></div><div class="line">    <span class="keyword">const</span> entry = <span class="keyword">this</span>._mutations[type]</div><div class="line"><span class="comment">//判断对应的mutation是否存在</span></div><div class="line">    <span class="keyword">if</span> (!entry) &#123;</div><div class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</div><div class="line">        <span class="built_in">console</span>.error(<span class="string">`[vuex] unknown mutation type: <span class="subst">$&#123;type&#125;</span>`</span>)</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">//将this.commtting变成true,即当前正在commting,在回调执行完成后再变更成false</span></div><div class="line">    <span class="keyword">this</span>._withCommit(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="comment">//触发mutation里对应的方法.</span></div><div class="line">      entry.forEach(<span class="function"><span class="keyword">function</span> <span class="title">commitIterator</span> (<span class="params">handler</span>) </span>&#123;</div><div class="line">        handler(payload)</div><div class="line">      &#125;)</div><div class="line">    &#125;)</div><div class="line"><span class="comment">//这里我们看到,每当我们的mutation执行完后这里就会把mutation和state作为参数发布订阅,可以在store.subscribe的回调中接收.通常用于vuex的插件,关于plugins的详细介绍可见官方文档https://vuex.vuejs.org/zh-cn/plugins.html</span></div><div class="line">    <span class="keyword">this</span>._subscribers.forEach(<span class="function"><span class="params">sub</span> =&gt;</span> sub(mutation, <span class="keyword">this</span>.state))</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (</div><div class="line">      process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</div><div class="line">      options &amp;&amp; options.silent</div><div class="line">    ) &#123;</div><div class="line">      <span class="built_in">console</span>.warn(</div><div class="line">        <span class="string">`[vuex] mutation type: <span class="subst">$&#123;type&#125;</span>. Silent option has been removed. `</span> +</div><div class="line">        <span class="string">'Use the filter functionality in the vue-devtools'</span></div><div class="line">      )</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>接下来是dispatch的实现.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">dispatch (_type, _payload) &#123;</div><div class="line">    <span class="comment">// 将传入的type和payload转换成统一的格式</span></div><div class="line">    <span class="keyword">const</span> &#123;</div><div class="line">      type,</div><div class="line">      payload</div><div class="line">    &#125; = unifyObjectStyle(_type, _payload)</div><div class="line"></div><div class="line">    <span class="keyword">const</span> action = &#123; type, payload &#125;</div><div class="line"><span class="comment">//获取actions里对应的方法名</span></div><div class="line">    <span class="keyword">const</span> entry = <span class="keyword">this</span>._actions[type]</div><div class="line"><span class="comment">//若没有对应的action方法则抛出异常</span></div><div class="line">    <span class="keyword">if</span> (!entry) &#123;</div><div class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</div><div class="line">        <span class="built_in">console</span>.error(<span class="string">`[vuex] unknown action type: <span class="subst">$&#123;type&#125;</span>`</span>)</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">//执行对应action的订阅事件</span></div><div class="line">    <span class="keyword">this</span>._actionSubscribers.forEach(<span class="function"><span class="params">sub</span> =&gt;</span> sub(action, <span class="keyword">this</span>.state))</div><div class="line"></div><div class="line"><span class="comment">//若同时存在多个同名方法则通过Promise.all来组合执行,否则直接执行返回promise</span></div><div class="line">    <span class="keyword">return</span> entry.length &gt; <span class="number">1</span></div><div class="line">      ? <span class="built_in">Promise</span>.all(entry.map(<span class="function"><span class="params">handler</span> =&gt;</span> handler(payload)))</div><div class="line">      : entry[<span class="number">0</span>](payload)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>另外,在installModule的时候,每个module通过递归在其module.context中也维护了对应的commit和dispatch方法.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> local = <span class="built_in">module</span>.context = makeLocalContext(store, namespace, path)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeLocalContext</span> (<span class="params">store, namespace, path</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> noNamespace = namespace === <span class="string">''</span></div><div class="line"></div><div class="line">  <span class="keyword">const</span> local = &#123;</div><div class="line"><span class="comment">//判断是否有namespace,无则直接使用store的dispatch,有则将namespace和type组合然后调用store.dispatch</span></div><div class="line">    dispatch: noNamespace ? store.dispatch : <span class="function">(<span class="params">_type, _payload, _options</span>) =&gt;</span> &#123;</div><div class="line">      <span class="keyword">const</span> args = unifyObjectStyle(_type, _payload, _options)</div><div class="line">      <span class="keyword">const</span> &#123; payload, options &#125; = args</div><div class="line">      <span class="keyword">let</span> &#123; type &#125; = args</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (!options || !options.root) &#123;</div><div class="line">        type = namespace + type</div><div class="line">        <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; !store._actions[type]) &#123;</div><div class="line">          <span class="built_in">console</span>.error(<span class="string">`[vuex] unknown local action type: <span class="subst">$&#123;args.type&#125;</span>, global type: <span class="subst">$&#123;type&#125;</span>`</span>)</div><div class="line">          <span class="keyword">return</span></div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">return</span> store.dispatch(type, payload)</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">//同dispatch判断是否有namespace,无则直接使用store的commit,有则将namespace和type组合然后调用store.commit</span></div><div class="line">    commit: noNamespace ? store.commit : <span class="function">(<span class="params">_type, _payload, _options</span>) =&gt;</span> &#123;</div><div class="line">      <span class="keyword">const</span> args = unifyObjectStyle(_type, _payload, _options)</div><div class="line">      <span class="keyword">const</span> &#123; payload, options &#125; = args</div><div class="line">      <span class="keyword">let</span> &#123; type &#125; = args</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (!options || !options.root) &#123;</div><div class="line">        type = namespace + type</div><div class="line">        <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; !store._mutations[type]) &#123;</div><div class="line">          <span class="built_in">console</span>.error(<span class="string">`[vuex] unknown local mutation type: <span class="subst">$&#123;args.type&#125;</span>, global type: <span class="subst">$&#123;type&#125;</span>`</span>)</div><div class="line">          <span class="keyword">return</span></div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      store.commit(type, payload, options)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// getters and state object must be gotten lazily</span></div><div class="line">  <span class="comment">// because they will be changed by vm update</span></div><div class="line">  <span class="built_in">Object</span>.defineProperties(local, &#123;</div><div class="line">    getters: &#123;</div><div class="line">      get: noNamespace</div><div class="line">        ? <span class="function"><span class="params">()</span> =&gt;</span> store.getters</div><div class="line">        : <span class="function"><span class="params">()</span> =&gt;</span> makeLocalGetters(store, namespace)</div><div class="line">    &#125;,</div><div class="line">    state: &#123;</div><div class="line">      get: <span class="function"><span class="params">()</span> =&gt;</span> getNestedState(store.state, path)</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line"></div><div class="line">  <span class="keyword">return</span> local</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>我们在actions中定义的方法回调中可以获得commit和dispatch,便是从这边来的.再来回顾下registerAction这个方法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">registerAction</span> (<span class="params">store, type, handler, local</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> entry = store._actions[type] || (store._actions[type] = [])</div><div class="line">  entry.push(<span class="function"><span class="keyword">function</span> <span class="title">wrappedActionHandler</span> (<span class="params">payload, cb</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> res = handler.call(store, &#123;</div><div class="line">      <span class="comment">//诺~这就是每个module内部的local,里面有对应的dispatch和commit</span></div><div class="line">      dispatch: local.dispatch,</div><div class="line">      commit: local.commit,</div><div class="line">      getters: local.getters,</div><div class="line">      state: local.state,</div><div class="line">      rootGetters: store.getters,</div><div class="line">      rootState: store.state</div><div class="line">    &#125;, payload, cb)</div><div class="line">    <span class="comment">//另外再讲一下,为什么异步的操作要放到action里,因为其内部方法的调用是通过promise来维护的.而mutation是直接调用</span></div><div class="line">    <span class="keyword">if</span> (!isPromise(res)) &#123;</div><div class="line">      res = <span class="built_in">Promise</span>.resolve(res)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (store._devtoolHook) &#123;</div><div class="line">      <span class="keyword">return</span> res.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</div><div class="line">        store._devtoolHook.emit(<span class="string">'vuex:error'</span>, err)</div><div class="line">        <span class="keyword">throw</span> err</div><div class="line">      &#125;)</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> res</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当我们配置好vuex并生成实例后,就可以开始玩耍了.观看vuex的文档的话你应该会知道如何修改state里的数据,即在mutions中定义方法去修改state,而外部通过store暴露出的commit方法来调用mutations中的方法.除了可以在外部使用外,在action
      
    
    </summary>
    
      <category term="vuex源码解析" scheme="http://yoursite.com/categories/vuex%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="vuex" scheme="http://yoursite.com/tags/vuex/"/>
    
  </entry>
  
  <entry>
    <title>构造函数及module</title>
    <link href="http://yoursite.com/2018/04/27/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%8Amodule/"/>
    <id>http://yoursite.com/2018/04/27/构造函数及module/</id>
    <published>2018-04-27T09:15:15.000Z</published>
    <updated>2018-04-29T06:41:59.746Z</updated>
    
    <content type="html"><![CDATA[<p>首先,我们平时使用vuex的语法是</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></div><div class="line"><span class="keyword">let</span> store = <span class="keyword">new</span> Vuex.store(&#123;</div><div class="line">state: &#123;</div><div class="line">count: <span class="number">0</span>,</div><div class="line">&#125;,</div><div class="line">mutations: &#123;</div><div class="line">add (state, n) &#123;</div><div class="line">state.count += n</div><div class="line">&#125;</div><div class="line">&#125;,</div><div class="line">......</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>那么,我们就从store的构造函数开始看.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//确保使用vuex前已经载入了vue</span></div><div class="line"><span class="keyword">if</span> (!Vue &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">'undefined'</span> &amp;&amp; <span class="built_in">window</span>.Vue) &#123;</div><div class="line">install(<span class="built_in">window</span>.Vue)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//确保浏览器支持promise以及当前的this指向store</span></div><div class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</div><div class="line">assert(Vue, <span class="string">`must call Vue.use(Vuex) before creating a store instance.`</span>)</div><div class="line">assert(<span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">'undefined'</span>, <span class="string">`vuex requires a Promise polyfill in this browser.`</span>)</div><div class="line">assert(<span class="keyword">this</span> <span class="keyword">instanceof</span> Store, <span class="string">`store must be called with the new operator.`</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>然后是store内部的状态</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// store internal state</span></div><div class="line"><span class="keyword">this</span>._committing = <span class="literal">false</span> <span class="comment">//当前是否在执行commit</span></div><div class="line"><span class="keyword">this</span>._actions = <span class="built_in">Object</span>.create(<span class="literal">null</span>)  <span class="comment">//保存actions</span></div><div class="line"><span class="keyword">this</span>._actionSubscribers = [] <span class="comment">//订阅actions调用的集合</span></div><div class="line"><span class="keyword">this</span>._mutations = <span class="built_in">Object</span>.create(<span class="literal">null</span>)  <span class="comment">//保存mutations</span></div><div class="line"><span class="keyword">this</span>._wrappedGetters = <span class="built_in">Object</span>.create(<span class="literal">null</span>)  <span class="comment">//保存包装好后的getter</span></div><div class="line"><span class="keyword">this</span>._modules = <span class="keyword">new</span> ModuleCollection(options) <span class="comment">//生成根节点的modules,属性即构造函数传入的options</span></div><div class="line"><span class="keyword">this</span>._modulesNamespaceMap = <span class="built_in">Object</span>.create(<span class="literal">null</span>)  <span class="comment">//modules对应的命名空间</span></div><div class="line"><span class="keyword">this</span>._subscribers = [] <span class="comment">//订阅mutations的集合.</span></div><div class="line"><span class="keyword">this</span>._watcherVM = <span class="keyword">new</span> Vue() <span class="comment">//生成一个vue的实例使state变为响应式</span></div><div class="line"></div><div class="line"><span class="comment">// 绑定commit和dispatch的上下文,防止store的this指向改变</span></div><div class="line"><span class="keyword">const</span> store = <span class="keyword">this</span></div><div class="line"><span class="keyword">const</span> &#123; dispatch, commit &#125; = <span class="keyword">this</span></div><div class="line"><span class="keyword">this</span>.dispatch = <span class="function"><span class="keyword">function</span> <span class="title">boundDispatch</span> (<span class="params">type, payload</span>) </span>&#123;</div><div class="line"><span class="keyword">return</span> dispatch.call(store, type, payload)</div><div class="line">&#125;</div><div class="line"><span class="keyword">this</span>.commit = <span class="function"><span class="keyword">function</span> <span class="title">boundCommit</span> (<span class="params">type, payload, options</span>) </span>&#123;</div><div class="line"><span class="keyword">return</span> commit.call(store, type, payload, options)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// strict mode</span></div><div class="line"><span class="keyword">this</span>.strict = strict</div><div class="line"><span class="comment">//这里的state就是根节点的state了.</span></div><div class="line"><span class="keyword">const</span> state = <span class="keyword">this</span>._modules.root.state</div><div class="line"></div><div class="line"><span class="comment">// init root module.</span></div><div class="line"><span class="comment">// this also recursively registers all sub-modules</span></div><div class="line"><span class="comment">// and collects all module getters inside this._wrappedGetters</span></div><div class="line"><span class="comment">//初始化root module,并且递归初始化所有子module</span></div><div class="line">installModule(<span class="keyword">this</span>, state, [], <span class="keyword">this</span>._modules.root)</div><div class="line"></div><div class="line"><span class="comment">// initialize the store vm, which is responsible for the reactivity</span></div><div class="line"><span class="comment">// (also registers _wrappedGetters as computed properties)</span></div><div class="line">resetStoreVM(<span class="keyword">this</span>, state)</div></pre></td></tr></table></figure><p>构造函数的内容大致介绍这些,我们来看一下构造函数里面调用的一些方法</p><h3 id="ModuleCollection"><a href="#ModuleCollection" class="headerlink" title="ModuleCollection"></a>ModuleCollection</h3><p>src/module/module-collection.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">constructor</span> (rawRootModule) &#123;</div><div class="line"><span class="comment">// register root module (Vuex.Store options)</span></div><div class="line"><span class="comment">//生成实例时传入store的option,注册生成root module</span></div><div class="line"><span class="keyword">this</span>.register([], rawRootModule, <span class="literal">false</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line">register (path, rawModule, runtime = <span class="literal">true</span>) &#123;</div><div class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</div><div class="line">assertRawModule(path, rawModule)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//生成一个Module实例</span></div><div class="line"><span class="keyword">const</span> newModule = <span class="keyword">new</span> Module(rawModule, runtime)</div><div class="line"><span class="keyword">if</span> (path.length === <span class="number">0</span>) &#123;</div><div class="line"><span class="comment">//绑定到根节点</span></div><div class="line"><span class="keyword">this</span>.root = newModule</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="comment">//获取父级module并将子module绑定</span></div><div class="line"><span class="keyword">const</span> parent = <span class="keyword">this</span>.get(path.slice(<span class="number">0</span>, <span class="number">-1</span>))</div><div class="line">parent.addChild(path[path.length - <span class="number">1</span>], newModule)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//递归初始化所有子module</span></div><div class="line"><span class="comment">// register nested modules</span></div><div class="line"><span class="keyword">if</span> (rawModule.modules) &#123;</div><div class="line">forEachValue(rawModule.modules, (rawChildModule, key) =&gt; &#123;</div><div class="line"><span class="keyword">this</span>.register(path.concat(key), rawChildModule, runtime)</div><div class="line">&#125;)</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里面注册module时声明了一个Module实例放到root,那么Module是怎么实现的呢?我们来看一下Module的构造函数</p><h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><p>./src/module/module.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">constructor</span> (rawModule, runtime) &#123;</div><div class="line">    <span class="keyword">this</span>.runtime = runtime</div><div class="line">    <span class="comment">// 子module</span></div><div class="line">    <span class="keyword">this</span>._children = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</div><div class="line">    <span class="comment">// 传入的module与该module下的state</span></div><div class="line">    <span class="keyword">this</span>._rawModule = rawModule</div><div class="line">    <span class="keyword">const</span> rawState = rawModule.state</div><div class="line"></div><div class="line">    <span class="comment">// 统一state风格为键值对形式</span></div><div class="line">    <span class="keyword">this</span>.state = (<span class="keyword">typeof</span> rawState === <span class="string">'function'</span> ? rawState() : rawState) || &#123;&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//添加子module</span></div><div class="line">addChild (key, <span class="built_in">module</span>) &#123;</div><div class="line"><span class="keyword">this</span>._children[key] = <span class="built_in">module</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如此一来,vuex里module树就建立和初始化我们就清楚了.接下来来看<code>installModule</code>的作用</p><h3 id="installModule"><a href="#installModule" class="headerlink" title="installModule"></a>installModule</h3><p>在store的构造函数中,<code>installModule</code>传入了4个参数,分别是Store,根module的state,一个空数组(path),以及根module</p><blockquote><p>installModule(this, state, [], this._modules.root)</p></blockquote><p>那我们来看看<code>installModule</code>函数内部做了什么</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">installModule</span> (<span class="params">store, rootState, path, module, hot</span>) </span>&#123;</div><div class="line"><span class="comment">//判断是否是根module</span></div><div class="line"><span class="keyword">const</span> isRoot = !path.length</div><div class="line"><span class="comment">//getNamespace的作用为将传入的path,即namespace以/拼接起来(namespace对应的module需真实存在</span></div><div class="line"><span class="keyword">const</span> namespace = store._modules.getNamespace(path)</div><div class="line"></div><div class="line"><span class="comment">//如果传入的module有namespaced,则将namespace作为_modulesNamespaceMap的key,将对应的module作为值存放,相当于一个快捷访问对应namespace的module的快捷方式</span></div><div class="line"><span class="keyword">if</span> (<span class="built_in">module</span>.namespaced) &#123;</div><div class="line">store._modulesNamespaceMap[namespace] = <span class="built_in">module</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (!isRoot &amp;&amp; !hot) &#123;</div><div class="line"><span class="comment">//使用vue.set来监听module的state,使其数据变成响应式的.</span></div><div class="line"><span class="keyword">const</span> parentState = getNestedState(rootState, path.slice(<span class="number">0</span>, <span class="number">-1</span>))</div><div class="line"><span class="keyword">const</span> moduleName = path[path.length - <span class="number">1</span>]</div><div class="line">store._withCommit(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">Vue.set(parentState, moduleName, <span class="built_in">module</span>.state)</div><div class="line">&#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//为当前module设置局部的commit和dispatch方法</span></div><div class="line"><span class="keyword">const</span> local = <span class="built_in">module</span>.context = makeLocalContext(store, namespace, path)</div><div class="line"></div><div class="line"><span class="comment">//循环当前module下配置的mutations</span></div><div class="line"><span class="built_in">module</span>.forEachMutation(<span class="function">(<span class="params">mutation, key</span>) =&gt;</span> &#123;</div><div class="line"><span class="comment">//通过namespace加上mutation方法名的形式生成独一无二的mutation方法名</span></div><div class="line"><span class="keyword">const</span> namespacedType = namespace + key</div><div class="line"><span class="comment">//注册mutation,得到包装后的mutation方法.</span></div><div class="line">registerMutation(store, namespacedType, mutation, local)</div><div class="line">&#125;)</div><div class="line"><span class="string">`registerMutation`</span>注册生成mutations方法大致如下</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">registerMutation</span> (<span class="params">store, type, handler, local</span>) </span>&#123;</div><div class="line"><span class="keyword">const</span> entry = store._mutations[type] || (store._mutations[type] = [])</div><div class="line">entry.push(<span class="function"><span class="keyword">function</span> <span class="title">wrappedMutationHandler</span> (<span class="params">payload</span>) </span>&#123;</div><div class="line">handler.call(store, local.state, payload)</div><div class="line">&#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>假设我们有个moduleA他的mutation有个方法叫count,那么生成的mutations大致如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">store._mutations.moduleAcount[</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrappedMutationHandler</span> (<span class="params">payload</span>) </span>&#123;</div><div class="line"><span class="comment">//这里的handler就是我们在moduleA里写的mutation的对应的方法,里面传入了我们需要的state合payload.</span></div><div class="line">handler.call(store, local.state, payload)</div><div class="line">&#125;</div><div class="line">......</div><div class="line">]</div></pre></td></tr></table></figure><p>同理,接下来是循环注册action,getter,并且递归为所以子module执行<code>installModule</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.forEachAction(<span class="function">(<span class="params">action, key</span>) =&gt;</span> &#123;</div><div class="line"><span class="keyword">const</span> type = action.root ? key : namespace + key</div><div class="line"><span class="keyword">const</span> handler = action.handler || action</div><div class="line">registerAction(store, type, handler, local)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="built_in">module</span>.forEachGetter(<span class="function">(<span class="params">getter, key</span>) =&gt;</span> &#123;</div><div class="line"><span class="keyword">const</span> namespacedType = namespace + key</div><div class="line">registerGetter(store, namespacedType, getter, local)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="built_in">module</span>.forEachChild(<span class="function">(<span class="params">child, key</span>) =&gt;</span> &#123;</div><div class="line">installModule(store, rootState, path.concat(key), child, hot)</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>其中registerAction稍微复杂一些</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">registerAction</span> (<span class="params">store, type, handler, local</span>) </span>&#123;</div><div class="line"><span class="keyword">const</span> entry = store._actions[type] || (store._actions[type] = [])</div><div class="line">entry.push(<span class="function"><span class="keyword">function</span> <span class="title">wrappedActionHandler</span> (<span class="params">payload, cb</span>) </span>&#123;</div><div class="line"><span class="comment">//暴露更多的方法,并且最终生成一个promise,同时也可支持回调</span></div><div class="line"><span class="keyword">let</span> res = handler.call(store, &#123;</div><div class="line">dispatch: local.dispatch,</div><div class="line">commit: local.commit,</div><div class="line">getters: local.getters,</div><div class="line">state: local.state,</div><div class="line">rootGetters: store.getters,</div><div class="line">rootState: store.state</div><div class="line">&#125;, payload, cb)</div><div class="line"><span class="keyword">if</span> (!isPromise(res)) &#123;</div><div class="line">res = <span class="built_in">Promise</span>.resolve(res)</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (store._devtoolHook) &#123;</div><div class="line"><span class="keyword">return</span> res.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</div><div class="line">store._devtoolHook.emit(<span class="string">'vuex:error'</span>, err)</div><div class="line"><span class="keyword">throw</span> err</div><div class="line">&#125;)</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="keyword">return</span> res</div><div class="line">&#125;</div><div class="line">&#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>至此,installModule方法也讲完了,还剩下最后的resetStoreVM.顾名思义这个方法就是重置vue的实例对象重新生成.把原来的state,getter方法都挂载到新的vue里,并且销毁原来的vue实例.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">resetStoreVM</span> (<span class="params">store, state, hot</span>) </span>&#123;</div><div class="line"><span class="keyword">const</span> oldVm = store._vm</div><div class="line"></div><div class="line"><span class="comment">// bind store public getters</span></div><div class="line">store.getters = &#123;&#125;</div><div class="line"><span class="keyword">const</span> wrappedGetters = store._wrappedGetters</div><div class="line"><span class="keyword">const</span> computed = &#123;&#125;</div><div class="line">forEachValue(wrappedGetters, (fn, key) =&gt; &#123;</div><div class="line"><span class="comment">// use computed to leverage its lazy-caching mechanism</span></div><div class="line">computed[key] = <span class="function"><span class="params">()</span> =&gt;</span> fn(store)</div><div class="line"><span class="built_in">Object</span>.defineProperty(store.getters, key, &#123;</div><div class="line">get: <span class="function"><span class="params">()</span> =&gt;</span> store._vm[key],</div><div class="line">enumerable: <span class="literal">true</span> <span class="comment">// for local getters</span></div><div class="line">&#125;)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// use a Vue instance to store the state tree</span></div><div class="line"><span class="comment">// suppress warnings just in case the user has added</span></div><div class="line"><span class="comment">// some funky global mixins</span></div><div class="line"><span class="keyword">const</span> silent = Vue.config.silent</div><div class="line">Vue.config.silent = <span class="literal">true</span></div><div class="line">store._vm = <span class="keyword">new</span> Vue(&#123;</div><div class="line">data: &#123;</div><div class="line">$$state: state</div><div class="line">&#125;,</div><div class="line">computed</div><div class="line">&#125;)</div><div class="line">Vue.config.silent = silent</div><div class="line"></div><div class="line"><span class="comment">// enable strict mode for new vm</span></div><div class="line"><span class="keyword">if</span> (store.strict) &#123;</div><div class="line">enableStrictMode(store)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (oldVm) &#123;</div><div class="line"><span class="keyword">if</span> (hot) &#123;</div><div class="line"><span class="comment">// dispatch changes in all subscribed watchers</span></div><div class="line"><span class="comment">// to force getter re-evaluation for hot reloading.</span></div><div class="line">store._withCommit(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">oldVm._data.$$state = <span class="literal">null</span></div><div class="line">&#125;)</div><div class="line">&#125;</div><div class="line">Vue.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> oldVm.$destroy())</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先,我们平时使用vuex的语法是&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;
      
    
    </summary>
    
      <category term="vuex源码解析" scheme="http://yoursite.com/categories/vuex%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="vuex" scheme="http://yoursite.com/tags/vuex/"/>
    
  </entry>
  
  <entry>
    <title>vuex源码解析 (前言)</title>
    <link href="http://yoursite.com/2018/04/27/vuex%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E5%89%8D%E8%A8%80/"/>
    <id>http://yoursite.com/2018/04/27/vuex源码解析-前言/</id>
    <published>2018-04-27T09:09:20.000Z</published>
    <updated>2018-04-27T09:28:44.769Z</updated>
    
    <content type="html"><![CDATA[<p>阅读vuex源码前首先说一下他的作用,主要就是为了解决在组件化开发时日益复杂的状态问题.当页面,组件,路由之间嵌套,各自的data又及其臃肿,组件间互相通信,,交互,在项目庞大后必定变的难以维护.而vuex就是专门基于vue的组件化开发时用来管理状态的插件.</p><h4 id="vuex核心概念"><a href="#vuex核心概念" class="headerlink" title="vuex核心概念"></a>vuex核心概念</h4><p>vue的核心概念主要分为</p><ul><li>state </li><li>getter</li><li>mutation</li><li>action</li><li>module</li></ul><p>所以接下来的源码解析也主要是围绕这五个方面.</p><h4 id="state"><a href="#state" class="headerlink" title="state"></a>state</h4><p>既然前面说了vuex是一个状态管理机,那么这里的state就是属于被管理的状态,在还没有阅读源码前有个疑问就是vue的state是怎样保存的,并且怎样保证其状态不会被随意更改</p><h4 id="getter"><a href="#getter" class="headerlink" title="getter"></a>getter</h4><p>大致可以理解成vue中的computer类似的方法,通过state或其它getter里的方法计算出一个结果return出去</p><h4 id="mutation"><a href="#mutation" class="headerlink" title="mutation"></a>mutation</h4><p>vue中提交更改state的方法.这里的疑问就是mutation提交,state更新后如何通知vue</p><h4 id="action"><a href="#action" class="headerlink" title="action"></a>action</h4><p>使用方法同mutation,主要用来执行异步的分发</p><h4 id="module"><a href="#module" class="headerlink" title="module"></a>module</h4><p>防止单一的状态树过于臃肿,所以将其拆分成module进行维护</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;阅读vuex源码前首先说一下他的作用,主要就是为了解决在组件化开发时日益复杂的状态问题.当页面,组件,路由之间嵌套,各自的data又及其臃肿,组件间互相通信,,交互,在项目庞大后必定变的难以维护.而vuex就是专门基于vue的组件化开发时用来管理状态的插件.&lt;/p&gt;
&lt;h4
      
    
    </summary>
    
      <category term="vuex源码解析" scheme="http://yoursite.com/categories/vuex%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="vuex" scheme="http://yoursite.com/tags/vuex/"/>
    
  </entry>
  
  <entry>
    <title>jquery jsonp设置jsonpCallback遇到的坑</title>
    <link href="http://yoursite.com/2018/04/24/jquery-jsonp%E8%AE%BE%E7%BD%AEjsonpCallback%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/"/>
    <id>http://yoursite.com/2018/04/24/jquery-jsonp设置jsonpCallback遇到的坑/</id>
    <published>2018-04-23T16:15:29.000Z</published>
    <updated>2018-04-27T10:03:48.904Z</updated>
    
    <content type="html"><![CDATA[<p>事情起因源自维护一份老的代码，其中跨域请求通过jsonp来获取数据，然后通过jquery的ajax方法来使用jsonp.</p><h4 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h4><p>代码中需要重复调用同一接口，但是接口在数据成功获取到的情况下，并未进入<code>success</code>回调，而是进入<code>error</code>，查看错误信息显示的是<code>abort</code>。</p><p>通过反复调试，最后发现<code>$.ajax</code>方法传入的<code>option</code>中有个参数叫<code>jsonpCallback</code>，其作用是指定<code>callback</code>回调时函数体的名称。这里写的是一个固定的值。试着修改通过给设定的<code>jsonpCallback</code>的值加入时间戳或者直接删除<code>jsonpCallback</code>，重复的请求jsonp就可以进入<code>success</code>了。虽然问题已经解决了，但其内在的逻辑仍需要探清。</p><h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h4><p>通过表象来看只是每次请求时<code>jsonpCallback</code>名称是否相同导致是否<code>success</code>，那么是什么原因呢？<code>jsonp</code>众所周知就是通过一个<code>script</code>标签来跨域请求目标服务器的对应接口数据，然后执行回调函数获得所需的data.所以按理说相同的回调函数名会影响得到其包裹的data吗？显然不会。那么可能就和<code>jquery</code>有关了。</p><h4 id="jquery源码（好像贴的是zepto的，无所谓了。）"><a href="#jquery源码（好像贴的是zepto的，无所谓了。）" class="headerlink" title="jquery源码（好像贴的是zepto的，无所谓了。）"></a>jquery源码（好像贴的是zepto的，无所谓了。）</h4><p>我们找到与jsonp相关的部分</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//options就是我们通过$.ajax传入的参数</span></div><div class="line">$.ajaxJSONP = <span class="function"><span class="keyword">function</span>(<span class="params">options, deferred</span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span> (!(<span class="string">'type'</span> <span class="keyword">in</span> options)) <span class="keyword">return</span> $.ajax(options)</div><div class="line">  <span class="comment">//我们传入的jsonpCallback赋值给了_callbackName，若没传，则callbackName就是一个随机动态的字符串</span></div><div class="line">  <span class="keyword">var</span> _callbackName = options.jsonpCallback,</div><div class="line">    callbackName = ($.isFunction(_callbackName) ?</div><div class="line">      _callbackName() : _callbackName) || (<span class="string">'Zepto'</span> + (jsonpID++)),</div><div class="line">      <span class="comment">//生成一个script标签，用来请求数据</span></div><div class="line">    script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>),</div><div class="line">    originalCallback = <span class="built_in">window</span>[callbackName],</div><div class="line">    responseData,</div><div class="line">    <span class="comment">//中断请求的方法</span></div><div class="line">    abort = <span class="function"><span class="keyword">function</span>(<span class="params">errorType</span>) </span>&#123;</div><div class="line">      $(script).triggerHandler(<span class="string">'error'</span>, errorType || <span class="string">'abort'</span>)</div><div class="line">    &#125;,</div><div class="line">    xhr = &#123; <span class="attr">abort</span>: abort &#125;, abortTimeout</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (deferred) deferred.promise(xhr)</div><div class="line">  <span class="comment">//监听script标签的load和error事件</span></div><div class="line">  $(script).on(<span class="string">'load error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e, errorType</span>)</span>&#123;</div><div class="line">    clearTimeout(abortTimeout)</div><div class="line">    <span class="comment">//移除script标签</span></div><div class="line">    $(script).off().remove()</div><div class="line">      <span class="comment">//若没有返回数据或者请求状态错误则抛出移除进入error,否则进入success</span></div><div class="line">    <span class="keyword">if</span> (e.type == <span class="string">'error'</span> || !responseData) &#123;</div><div class="line">      ajaxError(<span class="literal">null</span>, errorType || <span class="string">'error'</span>, xhr, options, deferred)</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      ajaxSuccess(responseData[<span class="number">0</span>], xhr, options, deferred)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//这里获取外层的originalCallback,也就是callbackName</span></div><div class="line">    <span class="built_in">window</span>[callbackName] = originalCallback</div><div class="line">    <span class="keyword">if</span> (responseData &amp;&amp; $.isFunction(originalCallback))</div><div class="line">      originalCallback(responseData[<span class="number">0</span>])</div><div class="line"></div><div class="line">    <span class="comment">//清空返回的responseData</span></div><div class="line">    originalCallback = responseData = <span class="literal">undefined</span></div><div class="line">  &#125;)</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (ajaxBeforeSend(xhr, options) === <span class="literal">false</span>) &#123;</div><div class="line">    abort(<span class="string">'abort'</span>)</div><div class="line">    <span class="keyword">return</span> xhr</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">//以callbackName为变量名声明函数，绑到window上，其传参就是responseData</span></div><div class="line">  <span class="built_in">window</span>[callbackName] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    responseData = <span class="built_in">arguments</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">//script标签的src即我们需要请求的接口的地址，将标签插入head</span></div><div class="line">  script.src = options.url.replace(<span class="regexp">/\?(.+)=\?/</span>, <span class="string">'?$1='</span> + callbackName)</div><div class="line">  <span class="built_in">document</span>.head.appendChild(script)</div><div class="line"></div><div class="line">  <span class="comment">//若超时则抛出异常。</span></div><div class="line">  <span class="keyword">if</span> (options.timeout &gt; <span class="number">0</span>) abortTimeout = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    abort(<span class="string">'timeout'</span>)</div><div class="line">  &#125;, options.timeout)</div><div class="line"></div><div class="line">  <span class="keyword">return</span> xhr</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里我们模拟一下使用<code>jquery</code>发起一个jsonp的请求的过程，就可以得出结论了。</p><ol><li>调用$.ajax方法</li><li>生成script标签</li><li>script标签上监听load和error事件</li><li>window上声明callbackName相同变量名的函数</li><li>script标签插入页面</li><li>回调执行拿到数据</li><li>下一个$.ajax方法执行</li></ol><p>看上去是这样没错，但实际却有很大区别。当短时间内有很多相同callbackName的jsonp请求时，事实并不能如我们意。js中有异步的概念，并不是从头到尾按顺序依次生效的。</p><p>其中，第三步的事件监听是一个异步的操作，js中异步的任务会由对应的异步模块单独处理。处理完后其回调方法会被丢到一个任务队列当中，待主线程的所有同步任务执行完成后才会从队列中取出最先进入的任务执行作。就像<code>setTimeout</code>就是很典型的一个异步任务。值得一提的是vue中有个<code>nextTick</code>方法就利用了异步的特性，使得其可以在数据更改后，双向数据绑定修改dom，在dom重新渲染(这里不做讨论双向数据绑定具体实现)完成之后再执行<code>nextTick</code>里的回调。因为<code>nextTick</code>方法的实现之一就是<code>timeout</code>，所以会在任务队列的末尾插入回调任务.此时可以确保回调执行时页面dom早已更新完毕。</p><p>言归正传，那么我们分析下整个过程。</p><ol><li>调用$.ajax方法</li><li>生成script标签</li><li>script标签上监听Load和error事件，对应的事件执行将扔到任务队列当中</li><li>script标签插入到页面当中，其请求过程是异步的，会被丢到任务队列，解析和执行过程是同步的，会产生阻塞。这里需要注意下，很多人弄不清其中的关系。网页加载过程中script标签是阻塞的，但阻塞的是后续的dom树的构建，其网络请求仍是异步的。</li><li>之前绑到window的回调执行，数据放到声明的responseData当中</li><li>下一个$.ajax方法调用，对应jquery里面的jsonp的方法重新初始化，且由于两次请求的callbackName名称相同，使得window上的该变量名的方法也重新赋值。上一个请求得到的responseData也成了undefined.</li><li>生成script标签发起异步的网络请求进入任务队列</li><li>此时主线程的同步任务已经执行完了。开始执行任务队列里上一个script标签onload触发的callback,</li><li>由于responseData已经成了undefinde，所以抛出异常，执行进入error当中。</li></ol><h4 id="最后我想说。。。还是早点把jquery扔了吧。。。"><a href="#最后我想说。。。还是早点把jquery扔了吧。。。" class="headerlink" title="最后我想说。。。还是早点把jquery扔了吧。。。"></a>最后我想说。。。还是早点把jquery扔了吧。。。</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;事情起因源自维护一份老的代码，其中跨域请求通过jsonp来获取数据，然后通过jquery的ajax方法来使用jsonp.&lt;/p&gt;
&lt;h4 id=&quot;问题：&quot;&gt;&lt;a href=&quot;#问题：&quot; class=&quot;headerlink&quot; title=&quot;问题：&quot;&gt;&lt;/a&gt;问题：&lt;/h4&gt;&lt;
      
    
    </summary>
    
    
      <category term="jquery" scheme="http://yoursite.com/tags/jquery/"/>
    
      <category term="任务队列" scheme="http://yoursite.com/tags/%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>audio标签与206状态码</title>
    <link href="http://yoursite.com/2017/10/25/audio-and-206/"/>
    <id>http://yoursite.com/2017/10/25/audio-and-206/</id>
    <published>2017-10-25T15:18:36.000Z</published>
    <updated>2018-04-24T08:38:14.054Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在此之前从没能把这俩家伙联系到一起过,因为本身处理媒体资源的经历也比较少。事情的开头是这样的,下午妹纸突然发微信给我,说是碰到个很奇怪的问题。audio标签引用mp3资源,在页面初次加载时拖动进度条,鼠标释放后自己又跑回了0:00的初始位置。音频资源缓冲完毕后再刷新就可以随意拖动了。</p><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>从妹纸那拿到音频资源的地址,然后写了个demo试验:</p><pre><code>&lt;audio src=&quot;http://101.132.40.17:8080/tccrm2_saas_ws2/monitor/Miaow-07-Bubble.mp3&quot; controls=&quot;controls&quot;&gt;&lt;/audio&gt;</code></pre><p>特意翻了下w3cschool,没有问题,但初次加载果然拖动后立马回到初始位置,等待资源缓冲完毕后可以随意拖动。清除缓存后再次打开又不行。<br>再次打开w3cschool,翻看了其事件和相关api,仍旧没有头绪。使用原生js的<code>currentTime</code>手动修改当前位置,结果仍旧是直接回到0:00。头大。</p><h3 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h3><p>网上搜索: audio标签拖拽进度条 一系列相关关键词,但是没找到任何有关系的结果。难道大家都没遇到过这个问题吗?于是我去stack overflow提问,英语虽渣但勉强把问题描述清楚了（外国朋友一定会觉得语法很奇怪）。<br>过了一会儿有人回答了,因为我把上面的代码也复制进去了,对方回答说:首先你的提问和你的代码没有关系,其次已经有类似的问题我已经做出解答了。(汗,我特意先搜过有没有相关问题了,但奈何英语差加上可能关键词不对),于是跳转到对方给的链接,问题是为什么我的audio标签进度条不工作,下面只有一个回答。不过并没有讲解决方案而是提到了206状态码。<br>206?<br>我特意去搜了一下。<br>表示该响应是表示客户端通过发送范围请求头Range抓取到了资源的部分数据,通常是用来:</p><ul><li>学习http头和状态.</li><li>解决网路问题.</li><li>解决大文件下载问题.</li><li>解决CDN和原始HTTP服务器问题.</li><li>使用工具例如lftp,wget,telnet测试断电续传.</li><li>测试将一个大文件分割成多个部分同时下载.</li></ul><h5 id="可是和我的audio标签的问题又有什么关联呢"><a href="#可是和我的audio标签的问题又有什么关联呢" class="headerlink" title="可是和我的audio标签的问题又有什么关联呢?"></a>可是和我的audio标签的问题又有什么关联呢?</h5><p>我仔细观察了下我的demo的网络请求,发现了点端倪。初次加载的时候响应的状态码是200,这时候控件是无法有效拖动的,即便缓冲成功。但是缓冲成功后再刷新页面,响应的状态码就成了206.貌似看到些曙光了,于是继续研究206状态。<br>原来206请求是个范围请求,<code>audio</code>标签的src请求媒体资源时请求头会带上<code>Range: bytes=0-</code>,意思就是告诉服务器我要发起个范围请求,并指定想要的字节范围。服务器收到后响应,如果支持的话那么响应头会带上<code>Content-Length</code>和<code>Accept-Ranges</code>,这时候audio标签的进度条就可以随意拖动进度。如果服务器不支持,那么也不会报错,仍旧可以成功的返回200状态,但是音频资源只能从头不间断的播放到尾。</p><h3 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h3><p>现在事情的脉络很清楚了,初次加载资源时,客户端向服务端发起了范围请求,服务端不支持（妥妥的后端的锅）,返回了个200状态码,音频照常播放,但是无法拖动进度。音频缓冲完毕后刷新页面,资源从缓存中读取,所以范围请求成功,返回206.进度条可以随意拖动。</p><h3 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h3><p>最大的收获就是让我对从没关注过的206范围请求,及audio相关的细节有了一定了解。不过这个坑乍一看实在太像前端的锅了,但是又和前端完全没关系,是后端没处理好。但是也告诉了我一件事,身为一个前端应该对http请求,以及各个状态码都要有一定了解,而不是简单的1xx,2xx,3xx,4xx开头代表什么。这样下次碰到类似的问题就可以很快定位到原因了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在此之前从没能把这俩家伙联系到一起过,因为本身处理媒体资源的经历也比较少。事情的开头是这样的,下午妹纸突然发微信给我,说是碰到个很奇怪的问题
      
    
    </summary>
    
    
      <category term="html5" scheme="http://yoursite.com/tags/html5/"/>
    
      <category term="http" scheme="http://yoursite.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>hexo配置</title>
    <link href="http://yoursite.com/2017/10/25/hexo-config/"/>
    <id>http://yoursite.com/2017/10/25/hexo-config/</id>
    <published>2017-10-25T13:47:57.000Z</published>
    <updated>2018-04-24T08:38:14.056Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><h5 id="为什么选择hexo"><a href="#为什么选择hexo" class="headerlink" title="为什么选择hexo?"></a>为什么选择hexo?</h5><p>以前也注册过博客园和csdn,不过没有经常逛与写的动力。后来学node的第一个demo就是用express搭一个博客。不过还是稍嫌烦了些。而hexo作为一个静态的博客,部署在github上,一切都简单很多。本来网上的教程已经很多了,在公司电脑上windows环境安装也很顺利。但是到家后用mac把项目clone下来运行碰到了一些坑,解决之后才有了自己记录下这个过程的想法。</p><h3 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h3><h5 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h5><p>Node的话可以去<a href="https://nodejs.org/en/" target="_blank" rel="external">官网</a>下载安装</p><h5 id="git"><a href="#git" class="headerlink" title="git"></a>git</h5><p>关于git的安装使用廖雪峰老师的<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137396287703354d8c6c01c904c7d9ff056ae23da865a000/" target="_blank" rel="external">网站</a>讲的也非常详细</p><h5 id="github"><a href="#github" class="headerlink" title="github"></a>github</h5><p>这个相信也不用我介绍了,全球最大的同性交友社区。创建和使用方式参照<a href="https://www.zhihu.com/question/20070065" target="_blank" rel="external">这里</a></p><h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><p>首先全局安装hexo:</p><pre><code>npm i -g hexo</code></pre><p>如果是mac的话记住在前面加<strong>sudo</strong><br>windows下安装正常,但是在我的mac下报错了。不知道是不是每个人都会遇到。错误如下:<br><img src="/2017/10/25/hexo-config/QQ20171025-222923@2x.png" alt="QQ20171025-222923@2x.png" title=""><br>这个问题卡了我很久,最后找到了解决方案,这里感谢这两篇博客。<a href="http://www.cnblogs.com/jiangzilong/p/6438748.html" target="_blank" rel="external">南不过远洋</a>,<a href="http://www.cnblogs.com/lidonghao/p/3543747.html" target="_blank" rel="external">李东浩</a></p><h5 id="解决方法如下"><a href="#解决方法如下" class="headerlink" title="解决方法如下:"></a>解决方法如下:</h5><p><code>npm config set user 0</code><br><code>npm config set unsafe-perm true</code><br>这时候再输入<code>sudo npm i -g hexo</code>,结果还是报错:<br><img src="/2017/10/25/hexo-config/QQ20171025-223937@2x.png" alt="QQ20171025-223937@2x.png" title=""><br>看错误信息让我删除<code>/usr/local/bin/hexo</code>,可能是之前安装失败但创建路目录,找到删掉,然后重新执行<code>sudo npm i -g hexo</code>,安装成功。</p><p>接下来就是创建目路,初始化。</p><pre><code>mkdir &lt;dir name&gt;cd &lt;dir name&gt;hexo init</code></pre><p>到此安装步骤就完成了。</p><h3 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h3><p>可以通过<code>hexo new &lt;title&gt;</code>新建文章,但是写好的文章怎么编译运行呢。</p><pre><code>hexo g  //生成静态页面hexo server //启动本地服务,可以在http://localhost:4000访问</code></pre><p>当然,生成静态页面之前最好<code>hexo clean</code>清理一下。不过如果每次编译运行都输入那么多命令还是挺麻烦的,这时候就可以借助npm的脚本来简化命令。<br>找到根目录下的<strong>package.json</strong>,在scripts中添加如下内容:</p><pre><code>&quot;scripts&quot;: {    &quot;dev&quot;: &quot;hexo clean &amp;&amp; hexo generate &amp;&amp; hexo server&quot; }</code></pre><p>这样以后直接输入<code>npm run dev</code>就可以了。</p><h3 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到github</h3><p>在github建立好【your_user_name.github.io】的项目,配置好ssh key。然后在本地项目根目录打开<strong>_config.yml</strong>文件,拉倒最底下,修改如下:</p><pre><code>deploy:  type: git  repo: git@github.com:Guste/Guste.github.io.git  //你的项目地址  branch: master</code></pre><p>然后安装<code>npm i hexo-deployer-git --save</code><br>接下来和之前一样,<code>hexo clean</code>,<code>hexo g</code>,不过最后一步变成了<code>hexo deploy</code>,当然这也也比较比较繁琐,这时候又可以用到npm script了。<br>打开package.json修改:</p><pre><code>&quot;scripts&quot;: {    &quot;build&quot;: &quot;hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy&quot;,    &quot;dev&quot;: &quot;hexo clean &amp;&amp; hexo generate &amp;&amp; hexo server&quot;}</code></pre><p>这也以后直接 <code>npm run build</code>就好了。运行成功,打开<a href="http://guste.github.io/" target="_blank" rel="external">http://guste.github.io/</a> (你对应的地址)就可以了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;h5 id=&quot;为什么选择hexo&quot;&gt;&lt;a href=&quot;#为什么选择hexo&quot; class=&quot;headerlink&quot; title=&quot;为什么选择he
      
    
    </summary>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
</feed>
