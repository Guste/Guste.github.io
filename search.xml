<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[video标签事件指北]]></title>
    <url>%2F2018%2F07%2F24%2Fvideo%E6%A0%87%E7%AD%BE%E4%BA%8B%E4%BB%B6%E6%8C%87%E5%8C%97%2F</url>
    <content type="text"><![CDATA[前言最近一直在维护一个短视频项目的移动web端,主要功能就是用自定义的播放器点播一个视频.目前市面上没有找到类似的UI,所以基于360奇舞团的chimee写了些UI插件.其中关于播放控制及状态管理的插件踩了不少坑,主要原因就是对video标签的事件流相对陌生,所以这里记录一下. video标签事件 事件 描述 loadstart 浏览器开始在网上寻找媒体数据 progress 浏览器正在获取媒体数据 suspend 浏览器暂停获取媒体数据，但是下载过程并滑正常结束 abort 浏览器在下载完全部媒体数据之前中止获取媒体数据，但是并不是由错误引起的 error 获取媒体数据过程中出错 emptied video元素或audio元素所在网络突然变为未初始化状态可能原因有两个: 1.载入媒体过程中突然发生一个致命错误 2.在浏览器正在选择支持的播放格式时，又调用 了load方法重新载入媒体 stalled 浏览器尝试获取媒体数据失败 play 即将开始播放，当执行了play方法时触发，或数据下载后元素被设为autoplay属性 pause 播放暂停，当执行了pause方式时触发 loadedmetadata 浏览器获取完毕媒体的时间长和字节数 loaded 浏览器加载当前帧结束 waiting 播放过程由于得不到下一帧而暂停播放（例如下一帧尚未加载完毕），但很快就能够得到下一帧 canplay 浏览器能够播放媒体，但估计以当前的播放速率不能直接播放完毕，播放期间需要缓冲 canplaythrough 浏览器能够播放媒体，而且以当前播放速率能够将媒体播放完毕，不再需要进行缓冲 seeking seeking属性变为true，浏览器正在请求数据 seeked seeking属性变为false，浏览器停止请求数据 timeupdate 由于播放位置被改变，可能是播放过程中的自然改变，也可能是被人为的改变，或由于播放不能连续而发生的跳变 ended 播放结束后停止播放 ratechange defaultplaybackRate属性（默认播放速率）或playbackRate属性（当前播放速率）被改变 druationchange 播放时长被改变 volumechange volume属性（音量）被改变或muted属性（静音状态）被改变 以上为目前网上搜索到的video相关事件的列表. 写个demo依次调用:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768let video = document.getElementsByTagName('video')[0];video.addEventListener('loadstart', () =&gt; &#123; console.log('loadstart')&#125;)video.addEventListener('error', () =&gt; &#123; console.log('error')&#125;)video.addEventListener('suspend', () =&gt; &#123; console.log('suspend')&#125;)video.addEventListener('emptied', () =&gt; &#123; console.log('emptied')&#125;)video.addEventListener('durationchange', () =&gt; &#123; console.log('durationchange')&#125;)video.addEventListener('loadedmetadata', () =&gt; &#123; console.log('loadedmetadata')&#125;)video.addEventListener('loadeddata', () =&gt; &#123; console.log('loadeddata')&#125;)video.addEventListener('abort', () =&gt; &#123; console.log('abort')&#125;)video.addEventListener('play', () =&gt; &#123; console.log('play')&#125;)video.addEventListener('pause', () =&gt; &#123; console.log('pause')&#125;)video.addEventListener('canplay', () =&gt; &#123; console.log('canplay')&#125;)video.addEventListener('canplaythrough', () =&gt; &#123; console.log('canplaythrough')&#125;)video.addEventListener('timeupdate', () =&gt; &#123; console.log('timeupdate')&#125;)video.addEventListener('progress', () =&gt; &#123; console.log('progress')&#125;)video.addEventListener('stalled', () =&gt; &#123; console.log('stalled')&#125;)video.addEventListener('seeking', () =&gt; &#123; console.log('seeking')&#125;)video.addEventListener('seeked', () =&gt; &#123; console.log('seeked')&#125;)video.addEventListener('waiting', () =&gt; &#123; console.log('waiting')&#125;)video.addEventListener('ratechange', () =&gt; &#123; console.log('ratechange')&#125;)video.addEventListener('druationchange', () =&gt; &#123; console.log('druationchange')&#125;)video.addEventListener('volumechange', () =&gt; &#123; console.log('volumechange')&#125;)video.addEventListener('ended', () =&gt; &#123; console.log('ended')&#125;) 视频初始化页面渲染完毕, video标签通过src引入媒体资源, 进行一系列初始化操作.这个过程中我们还没有对视频进行播放操作,其流程如下: 这里要注意,canplaythrough只是预计不会在播放过程中发生缓冲,实际过程中并不能保证.我就遇到了只播放零点几秒就继续缓冲的情况.关于请求媒体资源时206状态码的相关问题可以看我之前的文章:audio标签与206状态码 播放视频接下来我们点击视频播放按钮,播放一段时间后点击暂停,其输出结果如下: 首先触发play事件,然后timeupdate事件和progress事件互相交替不断触发.这里需要注意,当视频以缓冲内容播放完时,timeupdate事件就会停止触发,等待progress不断获取一定量的时候才会继续进行,这就是我们常见的视频的loading状态按理应该也在此阶段触发.因为这方面经验不足,所以处理方法不知是否得当,我是通过progress传入的当前event的buffered来进行判断.buffered为以缓冲的媒体片段,通过获取的最后一个片段的结尾位置和当前视频的currentTime进行比对来决定是否需要展示loading.(如果有更好的方法欢迎提出).期间canplaythrough又有触发,说明其不是在初始化时执行一次就不再执行了,这里需要注意.最后点击暂停按钮触发pause事件,且progress事件不再触发. 跳转至为缓冲区域 如图所示,红框位置为播放器未缓冲区域,我们可以观察跳转至未缓冲区域时的事件触发状况.触发流程如下:seeking代表用户目前跳转了进度,浏览器正在寻址中.并且开始缓冲后续片段,然后触发了timeupdate,代表已经更新了当前的时间,这时候才seeked,寻址结束.并且canplay和canplaythrough再次触发 跳转至以缓冲区域 跳转,然后直接timeupdate,跳转结束,视频可以播放.接着再次触发progress发起请求来确认后续内容,最后canplaythrough. 拖动进度条我们拖动进度条快速的滑动但不具体的停止在某个点上,其表现为不停的触发seeking,说明在不停的寻址.当我们悬停在某个位置上但却没有松开按键,progress触发,然后timeupdate -&gt; seeked -&gt; canplay -&gt; canplaythrough.此过程中画面已经切换到对应时间的那一帧. 播放结束最后视频播放结束时先触发了pause然后ended. 以上就是对于video标签播放时的事件流触发的梳理,如有遗漏或错误欢迎指正.]]></content>
      <tags>
        <tag>video</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuex的commit和dispatch方法实现]]></title>
    <url>%2F2018%2F04%2F29%2Fvuex%E7%9A%84commit%E5%92%8Cdispatch%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[当我们配置好vuex并生成实例后,就可以开始玩耍了.观看vuex的文档的话你应该会知道如何修改state里的数据,即在mutions中定义方法去修改state,而外部通过store暴露出的commit方法来调用mutations中的方法.除了可以在外部使用外,在action中执行完了异步操作我们也是通过commit方法来调用mution提交state的修改.所以接下来我们看一下commit的实现.12345678910111213141516171819202122232425262728293031323334353637383940//type: mutions中的方法名,payload为mutions中方法的传参commit (_type, _payload, _options) &#123; // 将传入的type,payload,options转换成统一格式 const &#123; type, payload, options &#125; = unifyObjectStyle(_type, _payload, _options) const mutation = &#123; type, payload &#125; //从_mutations中获取对应type的方法 const entry = this._mutations[type] //判断对应的mutation是否存在 if (!entry) &#123; if (process.env.NODE_ENV !== 'production') &#123; console.error(`[vuex] unknown mutation type: $&#123;type&#125;`) &#125; return &#125; //将this.commtting变成true,即当前正在commting,在回调执行完成后再变更成false this._withCommit(() =&gt; &#123; //触发mutation里对应的方法. entry.forEach(function commitIterator (handler) &#123; handler(payload) &#125;) &#125;) //这里我们看到,每当我们的mutation执行完后这里就会把mutation和state作为参数发布订阅,可以在store.subscribe的回调中接收.通常用于vuex的插件,关于plugins的详细介绍可见官方文档https://vuex.vuejs.org/zh-cn/plugins.html this._subscribers.forEach(sub =&gt; sub(mutation, this.state)) if ( process.env.NODE_ENV !== 'production' &amp;&amp; options &amp;&amp; options.silent ) &#123; console.warn( `[vuex] mutation type: $&#123;type&#125;. Silent option has been removed. ` + 'Use the filter functionality in the vue-devtools' ) &#125;&#125; 接下来是dispatch的实现.1234567891011121314151617181920212223242526dispatch (_type, _payload) &#123; // 将传入的type和payload转换成统一的格式 const &#123; type, payload &#125; = unifyObjectStyle(_type, _payload) const action = &#123; type, payload &#125; //获取actions里对应的方法名 const entry = this._actions[type] //若没有对应的action方法则抛出异常 if (!entry) &#123; if (process.env.NODE_ENV !== 'production') &#123; console.error(`[vuex] unknown action type: $&#123;type&#125;`) &#125; return &#125; //执行对应action的订阅事件 this._actionSubscribers.forEach(sub =&gt; sub(action, this.state)) //若同时存在多个同名方法则通过Promise.all来组合执行,否则直接执行返回promise return entry.length &gt; 1 ? Promise.all(entry.map(handler =&gt; handler(payload))) : entry[0](payload)&#125; 另外,在installModule的时候,每个module通过递归在其module.context中也维护了对应的commit和dispatch方法.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455const local = module.context = makeLocalContext(store, namespace, path)function makeLocalContext (store, namespace, path) &#123; const noNamespace = namespace === '' const local = &#123; //判断是否有namespace,无则直接使用store的dispatch,有则将namespace和type组合然后调用store.dispatch dispatch: noNamespace ? store.dispatch : (_type, _payload, _options) =&gt; &#123; const args = unifyObjectStyle(_type, _payload, _options) const &#123; payload, options &#125; = args let &#123; type &#125; = args if (!options || !options.root) &#123; type = namespace + type if (process.env.NODE_ENV !== 'production' &amp;&amp; !store._actions[type]) &#123; console.error(`[vuex] unknown local action type: $&#123;args.type&#125;, global type: $&#123;type&#125;`) return &#125; &#125; return store.dispatch(type, payload) &#125;, //同dispatch判断是否有namespace,无则直接使用store的commit,有则将namespace和type组合然后调用store.commit commit: noNamespace ? store.commit : (_type, _payload, _options) =&gt; &#123; const args = unifyObjectStyle(_type, _payload, _options) const &#123; payload, options &#125; = args let &#123; type &#125; = args if (!options || !options.root) &#123; type = namespace + type if (process.env.NODE_ENV !== 'production' &amp;&amp; !store._mutations[type]) &#123; console.error(`[vuex] unknown local mutation type: $&#123;args.type&#125;, global type: $&#123;type&#125;`) return &#125; &#125; store.commit(type, payload, options) &#125; &#125; // getters and state object must be gotten lazily // because they will be changed by vm update Object.defineProperties(local, &#123; getters: &#123; get: noNamespace ? () =&gt; store.getters : () =&gt; makeLocalGetters(store, namespace) &#125;, state: &#123; get: () =&gt; getNestedState(store.state, path) &#125; &#125;) return local&#125; 我们在actions中定义的方法回调中可以获得commit和dispatch,便是从这边来的.再来回顾下registerAction这个方法1234567891011121314151617181920212223242526function registerAction (store, type, handler, local) &#123; const entry = store._actions[type] || (store._actions[type] = []) entry.push(function wrappedActionHandler (payload, cb) &#123; let res = handler.call(store, &#123; //诺~这就是每个module内部的local,里面有对应的dispatch和commit dispatch: local.dispatch, commit: local.commit, getters: local.getters, state: local.state, rootGetters: store.getters, rootState: store.state &#125;, payload, cb) //另外再讲一下,为什么异步的操作要放到action里,因为其内部方法的调用是通过promise来维护的.而mutation是直接调用 if (!isPromise(res)) &#123; res = Promise.resolve(res) &#125; if (store._devtoolHook) &#123; return res.catch(err =&gt; &#123; store._devtoolHook.emit('vuex:error', err) throw err &#125;) &#125; else &#123; return res &#125; &#125;)&#125;]]></content>
      <categories>
        <category>vuex源码解析</category>
      </categories>
      <tags>
        <tag>vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构造函数及module]]></title>
    <url>%2F2018%2F04%2F27%2F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%8Amodule%2F</url>
    <content type="text"><![CDATA[首先,我们平时使用vuex的语法是 123456789101112import Vuex from 'vuex'let store = new Vuex.store(&#123; state: &#123; count: 0, &#125;, mutations: &#123; add (state, n) &#123; state.count += n &#125; &#125;, ......&#125;) 那么,我们就从store的构造函数开始看. 1234567891011//确保使用vuex前已经载入了vueif (!Vue &amp;&amp; typeof window !== 'undefined' &amp;&amp; window.Vue) &#123; install(window.Vue) &#125;//确保浏览器支持promise以及当前的this指向storeif (process.env.NODE_ENV !== 'production') &#123; assert(Vue, `must call Vue.use(Vuex) before creating a store instance.`) assert(typeof Promise !== 'undefined', `vuex requires a Promise polyfill in this browser.`) assert(this instanceof Store, `store must be called with the new operator.`)&#125; 然后是store内部的状态 1234567891011121314151617181920212223242526272829303132333435// store internal statethis._committing = false //当前是否在执行committhis._actions = Object.create(null) //保存actionsthis._actionSubscribers = [] //订阅actions调用的集合this._mutations = Object.create(null) //保存mutationsthis._wrappedGetters = Object.create(null) //保存包装好后的getterthis._modules = new ModuleCollection(options) //生成根节点的modules,属性即构造函数传入的optionsthis._modulesNamespaceMap = Object.create(null) //modules对应的命名空间this._subscribers = [] //订阅mutations的集合.this._watcherVM = new Vue() //生成一个vue的实例使state变为响应式// 绑定commit和dispatch的上下文,防止store的this指向改变const store = thisconst &#123; dispatch, commit &#125; = thisthis.dispatch = function boundDispatch (type, payload) &#123; return dispatch.call(store, type, payload)&#125;this.commit = function boundCommit (type, payload, options) &#123; return commit.call(store, type, payload, options)&#125;// strict modethis.strict = strict//这里的state就是根节点的state了.const state = this._modules.root.state// init root module.// this also recursively registers all sub-modules// and collects all module getters inside this._wrappedGetters//初始化root module,并且递归初始化所有子moduleinstallModule(this, state, [], this._modules.root)// initialize the store vm, which is responsible for the reactivity// (also registers _wrappedGetters as computed properties)resetStoreVM(this, state) 构造函数的内容大致介绍这些,我们来看一下构造函数里面调用的一些方法 ModuleCollectionsrc/module/module-collection.js 123456789101112131415161718192021222324252627282930constructor (rawRootModule) &#123; // register root module (Vuex.Store options) //生成实例时传入store的option,注册生成root module this.register([], rawRootModule, false)&#125;register (path, rawModule, runtime = true) &#123; if (process.env.NODE_ENV !== 'production') &#123; assertRawModule(path, rawModule) &#125;//生成一个Module实例 const newModule = new Module(rawModule, runtime) if (path.length === 0) &#123; //绑定到根节点 this.root = newModule &#125; else &#123; //获取父级module并将子module绑定 const parent = this.get(path.slice(0, -1)) parent.addChild(path[path.length - 1], newModule) &#125;//递归初始化所有子module // register nested modules if (rawModule.modules) &#123; forEachValue(rawModule.modules, (rawChildModule, key) =&gt; &#123; this.register(path.concat(key), rawChildModule, runtime) &#125;) &#125;&#125; 这里面注册module时声明了一个Module实例放到root,那么Module是怎么实现的呢?我们来看一下Module的构造函数 Module./src/module/module.js 123456789101112131415constructor (rawModule, runtime) &#123; this.runtime = runtime // 子module this._children = Object.create(null) // 传入的module与该module下的state this._rawModule = rawModule const rawState = rawModule.state // 统一state风格为键值对形式 this.state = (typeof rawState === 'function' ? rawState() : rawState) || &#123;&#125;&#125;//添加子moduleaddChild (key, module) &#123; this._children[key] = module&#125; 如此一来,vuex里module树就建立和初始化我们就清楚了.接下来来看installModule的作用 installModule在store的构造函数中,installModule传入了4个参数,分别是Store,根module的state,一个空数组(path),以及根module installModule(this, state, [], this._modules.root) 那我们来看看installModule函数内部做了什么 1234567891011121314151617181920212223242526272829303132333435363738function installModule (store, rootState, path, module, hot) &#123; //判断是否是根module const isRoot = !path.length //getNamespace的作用为将传入的path,即namespace以/拼接起来(namespace对应的module需真实存在 const namespace = store._modules.getNamespace(path) //如果传入的module有namespaced,则将namespace作为_modulesNamespaceMap的key,将对应的module作为值存放,相当于一个快捷访问对应namespace的module的快捷方式 if (module.namespaced) &#123; store._modulesNamespaceMap[namespace] = module &#125; if (!isRoot &amp;&amp; !hot) &#123; //使用vue.set来监听module的state,使其数据变成响应式的. const parentState = getNestedState(rootState, path.slice(0, -1)) const moduleName = path[path.length - 1] store._withCommit(() =&gt; &#123; Vue.set(parentState, moduleName, module.state) &#125;) &#125; //为当前module设置局部的commit和dispatch方法 const local = module.context = makeLocalContext(store, namespace, path) //循环当前module下配置的mutations module.forEachMutation((mutation, key) =&gt; &#123; //通过namespace加上mutation方法名的形式生成独一无二的mutation方法名 const namespacedType = namespace + key //注册mutation,得到包装后的mutation方法. registerMutation(store, namespacedType, mutation, local) &#125;)`registerMutation`注册生成mutations方法大致如下function registerMutation (store, type, handler, local) &#123; const entry = store._mutations[type] || (store._mutations[type] = []) entry.push(function wrappedMutationHandler (payload) &#123; handler.call(store, local.state, payload) &#125;)&#125; 假设我们有个moduleA他的mutation有个方法叫count,那么生成的mutations大致如下 1234567store._mutations.moduleAcount[ function wrappedMutationHandler (payload) &#123; //这里的handler就是我们在moduleA里写的mutation的对应的方法,里面传入了我们需要的state合payload. handler.call(store, local.state, payload) &#125; ......] 同理,接下来是循环注册action,getter,并且递归为所以子module执行installModule 1234567891011121314module.forEachAction((action, key) =&gt; &#123; const type = action.root ? key : namespace + key const handler = action.handler || action registerAction(store, type, handler, local)&#125;)module.forEachGetter((getter, key) =&gt; &#123; const namespacedType = namespace + key registerGetter(store, namespacedType, getter, local)&#125;) module.forEachChild((child, key) =&gt; &#123; installModule(store, rootState, path.concat(key), child, hot)&#125;) 其中registerAction稍微复杂一些 12345678910111213141516171819202122232425function registerAction (store, type, handler, local) &#123; const entry = store._actions[type] || (store._actions[type] = []) entry.push(function wrappedActionHandler (payload, cb) &#123; //暴露更多的方法,并且最终生成一个promise,同时也可支持回调 let res = handler.call(store, &#123; dispatch: local.dispatch, commit: local.commit, getters: local.getters, state: local.state, rootGetters: store.getters, rootState: store.state &#125;, payload, cb) if (!isPromise(res)) &#123; res = Promise.resolve(res) &#125; if (store._devtoolHook) &#123; return res.catch(err =&gt; &#123; store._devtoolHook.emit('vuex:error', err) throw err &#125;) &#125; else &#123; return res &#125; &#125;)&#125; 至此,installModule方法也讲完了,还剩下最后的resetStoreVM.顾名思义这个方法就是重置vue的实例对象重新生成.把原来的state,getter方法都挂载到新的vue里,并且销毁原来的vue实例. 123456789101112131415161718192021222324252627282930313233343536373839404142434445function resetStoreVM (store, state, hot) &#123; const oldVm = store._vm // bind store public getters store.getters = &#123;&#125; const wrappedGetters = store._wrappedGetters const computed = &#123;&#125; forEachValue(wrappedGetters, (fn, key) =&gt; &#123; // use computed to leverage its lazy-caching mechanism computed[key] = () =&gt; fn(store) Object.defineProperty(store.getters, key, &#123; get: () =&gt; store._vm[key], enumerable: true // for local getters &#125;) &#125;) // use a Vue instance to store the state tree // suppress warnings just in case the user has added // some funky global mixins const silent = Vue.config.silent Vue.config.silent = true store._vm = new Vue(&#123; data: &#123; $$state: state &#125;, computed &#125;) Vue.config.silent = silent // enable strict mode for new vm if (store.strict) &#123; enableStrictMode(store) &#125; if (oldVm) &#123; if (hot) &#123; // dispatch changes in all subscribed watchers // to force getter re-evaluation for hot reloading. store._withCommit(() =&gt; &#123; oldVm._data.$$state = null &#125;) &#125; Vue.nextTick(() =&gt; oldVm.$destroy()) &#125;&#125;]]></content>
      <categories>
        <category>vuex源码解析</category>
      </categories>
      <tags>
        <tag>vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuex源码解析 (前言)]]></title>
    <url>%2F2018%2F04%2F27%2Fvuex%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E5%89%8D%E8%A8%80%2F</url>
    <content type="text"><![CDATA[阅读vuex源码前首先说一下他的作用,主要就是为了解决在组件化开发时日益复杂的状态问题.当页面,组件,路由之间嵌套,各自的data又及其臃肿,组件间互相通信,,交互,在项目庞大后必定变的难以维护.而vuex就是专门基于vue的组件化开发时用来管理状态的插件. vuex核心概念vue的核心概念主要分为 state getter mutation action module 所以接下来的源码解析也主要是围绕这五个方面. state既然前面说了vuex是一个状态管理机,那么这里的state就是属于被管理的状态,在还没有阅读源码前有个疑问就是vue的state是怎样保存的,并且怎样保证其状态不会被随意更改 getter大致可以理解成vue中的computer类似的方法,通过state或其它getter里的方法计算出一个结果return出去 mutationvue中提交更改state的方法.这里的疑问就是mutation提交,state更新后如何通知vue action使用方法同mutation,主要用来执行异步的分发 module防止单一的状态树过于臃肿,所以将其拆分成module进行维护]]></content>
      <categories>
        <category>vuex源码解析</category>
      </categories>
      <tags>
        <tag>vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery jsonp设置jsonpCallback遇到的坑]]></title>
    <url>%2F2018%2F04%2F24%2Fjquery-jsonp%E8%AE%BE%E7%BD%AEjsonpCallback%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[事情起因源自维护一份老的代码，其中跨域请求通过jsonp来获取数据，然后通过jquery的ajax方法来使用jsonp. 问题：代码中需要重复调用同一接口，但是接口在数据成功获取到的情况下，并未进入success回调，而是进入error，查看错误信息显示的是abort。 通过反复调试，最后发现$.ajax方法传入的option中有个参数叫jsonpCallback，其作用是指定callback回调时函数体的名称。这里写的是一个固定的值。试着修改通过给设定的jsonpCallback的值加入时间戳或者直接删除jsonpCallback，重复的请求jsonp就可以进入success了。虽然问题已经解决了，但其内在的逻辑仍需要探清。 分析：通过表象来看只是每次请求时jsonpCallback名称是否相同导致是否success，那么是什么原因呢？jsonp众所周知就是通过一个script标签来跨域请求目标服务器的对应接口数据，然后执行回调函数获得所需的data.所以按理说相同的回调函数名会影响得到其包裹的data吗？显然不会。那么可能就和jquery有关了。 jquery源码（好像贴的是zepto的，无所谓了。）我们找到与jsonp相关的部分 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//options就是我们通过$.ajax传入的参数$.ajaxJSONP = function(options, deferred)&#123; if (!('type' in options)) return $.ajax(options) //我们传入的jsonpCallback赋值给了_callbackName，若没传，则callbackName就是一个随机动态的字符串 var _callbackName = options.jsonpCallback, callbackName = ($.isFunction(_callbackName) ? _callbackName() : _callbackName) || ('Zepto' + (jsonpID++)), //生成一个script标签，用来请求数据 script = document.createElement('script'), originalCallback = window[callbackName], responseData, //中断请求的方法 abort = function(errorType) &#123; $(script).triggerHandler('error', errorType || 'abort') &#125;, xhr = &#123; abort: abort &#125;, abortTimeout if (deferred) deferred.promise(xhr) //监听script标签的load和error事件 $(script).on('load error', function(e, errorType)&#123; clearTimeout(abortTimeout) //移除script标签 $(script).off().remove() //若没有返回数据或者请求状态错误则抛出移除进入error,否则进入success if (e.type == 'error' || !responseData) &#123; ajaxError(null, errorType || 'error', xhr, options, deferred) &#125; else &#123; ajaxSuccess(responseData[0], xhr, options, deferred) &#125; //这里获取外层的originalCallback,也就是callbackName window[callbackName] = originalCallback if (responseData &amp;&amp; $.isFunction(originalCallback)) originalCallback(responseData[0]) //清空返回的responseData originalCallback = responseData = undefined &#125;) if (ajaxBeforeSend(xhr, options) === false) &#123; abort('abort') return xhr &#125; //以callbackName为变量名声明函数，绑到window上，其传参就是responseData window[callbackName] = function()&#123; responseData = arguments &#125; //script标签的src即我们需要请求的接口的地址，将标签插入head script.src = options.url.replace(/\?(.+)=\?/, '?$1=' + callbackName) document.head.appendChild(script) //若超时则抛出异常。 if (options.timeout &gt; 0) abortTimeout = setTimeout(function()&#123; abort('timeout') &#125;, options.timeout) return xhr&#125; 这里我们模拟一下使用jquery发起一个jsonp的请求的过程，就可以得出结论了。 调用$.ajax方法 生成script标签 script标签上监听load和error事件 window上声明callbackName相同变量名的函数 script标签插入页面 回调执行拿到数据 下一个$.ajax方法执行 看上去是这样没错，但实际却有很大区别。当短时间内有很多相同callbackName的jsonp请求时，事实并不能如我们意。js中有异步的概念，并不是从头到尾按顺序依次生效的。 其中，第三步的事件监听是一个异步的操作，js中异步的任务会由对应的异步模块单独处理。处理完后其回调方法会被丢到一个任务队列当中，待主线程的所有同步任务执行完成后才会从队列中取出最先进入的任务执行作。就像setTimeout就是很典型的一个异步任务。值得一提的是vue中有个nextTick方法就利用了异步的特性，使得其可以在数据更改后，双向数据绑定修改dom，在dom重新渲染(这里不做讨论双向数据绑定具体实现)完成之后再执行nextTick里的回调。因为nextTick方法的实现之一就是timeout，所以会在任务队列的末尾插入回调任务.此时可以确保回调执行时页面dom早已更新完毕。 言归正传，那么我们分析下整个过程。 调用$.ajax方法 生成script标签 script标签上监听Load和error事件，对应的事件执行将扔到任务队列当中 script标签插入到页面当中，其请求过程是异步的，会被丢到任务队列，解析和执行过程是同步的，会产生阻塞。这里需要注意下，很多人弄不清其中的关系。网页加载过程中script标签是阻塞的，但阻塞的是后续的dom树的构建，其网络请求仍是异步的。 之前绑到window的回调执行，数据放到声明的responseData当中 下一个$.ajax方法调用，对应jquery里面的jsonp的方法重新初始化，且由于两次请求的callbackName名称相同，使得window上的该变量名的方法也重新赋值。上一个请求得到的responseData也成了undefined. 生成script标签发起异步的网络请求进入任务队列 此时主线程的同步任务已经执行完了。开始执行任务队列里上一个script标签onload触发的callback, 由于responseData已经成了undefinde，所以抛出异常，执行进入error当中。 最后我想说。。。还是早点把jquery扔了吧。。。]]></content>
      <tags>
        <tag>jquery</tag>
        <tag>任务队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[audio标签与206状态码]]></title>
    <url>%2F2017%2F10%2F25%2Faudio-and-206%2F</url>
    <content type="text"><![CDATA[前言在此之前从没能把这俩家伙联系到一起过,因为本身处理媒体资源的经历也比较少。事情的开头是这样的,下午妹纸突然发微信给我,说是碰到个很奇怪的问题。audio标签引用mp3资源,在页面初次加载时拖动进度条,鼠标释放后自己又跑回了0:00的初始位置。音频资源缓冲完毕后再刷新就可以随意拖动了。 实践从妹纸那拿到音频资源的地址,然后写了个demo试验: &lt;audio src=&quot;http://101.132.40.17:8080/tccrm2_saas_ws2/monitor/Miaow-07-Bubble.mp3&quot; controls=&quot;controls&quot;&gt;&lt;/audio&gt; 特意翻了下w3cschool,没有问题,但初次加载果然拖动后立马回到初始位置,等待资源缓冲完毕后可以随意拖动。清除缓存后再次打开又不行。再次打开w3cschool,翻看了其事件和相关api,仍旧没有头绪。使用原生js的currentTime手动修改当前位置,结果仍旧是直接回到0:00。头大。 搜索引擎网上搜索: audio标签拖拽进度条 一系列相关关键词,但是没找到任何有关系的结果。难道大家都没遇到过这个问题吗?于是我去stack overflow提问,英语虽渣但勉强把问题描述清楚了（外国朋友一定会觉得语法很奇怪）。过了一会儿有人回答了,因为我把上面的代码也复制进去了,对方回答说:首先你的提问和你的代码没有关系,其次已经有类似的问题我已经做出解答了。(汗,我特意先搜过有没有相关问题了,但奈何英语差加上可能关键词不对),于是跳转到对方给的链接,问题是为什么我的audio标签进度条不工作,下面只有一个回答。不过并没有讲解决方案而是提到了206状态码。206?我特意去搜了一下。表示该响应是表示客户端通过发送范围请求头Range抓取到了资源的部分数据,通常是用来: 学习http头和状态. 解决网路问题. 解决大文件下载问题. 解决CDN和原始HTTP服务器问题. 使用工具例如lftp,wget,telnet测试断电续传. 测试将一个大文件分割成多个部分同时下载. 可是和我的audio标签的问题又有什么关联呢?我仔细观察了下我的demo的网络请求,发现了点端倪。初次加载的时候响应的状态码是200,这时候控件是无法有效拖动的,即便缓冲成功。但是缓冲成功后再刷新页面,响应的状态码就成了206.貌似看到些曙光了,于是继续研究206状态。原来206请求是个范围请求,audio标签的src请求媒体资源时请求头会带上Range: bytes=0-,意思就是告诉服务器我要发起个范围请求,并指定想要的字节范围。服务器收到后响应,如果支持的话那么响应头会带上Content-Length和Accept-Ranges,这时候audio标签的进度条就可以随意拖动进度。如果服务器不支持,那么也不会报错,仍旧可以成功的返回200状态,但是音频资源只能从头不间断的播放到尾。 问题总结现在事情的脉络很清楚了,初次加载资源时,客户端向服务端发起了范围请求,服务端不支持（妥妥的后端的锅）,返回了个200状态码,音频照常播放,但是无法拖动进度。音频缓冲完毕后刷新页面,资源从缓存中读取,所以范围请求成功,返回206.进度条可以随意拖动。 感想最大的收获就是让我对从没关注过的206范围请求,及audio相关的细节有了一定了解。不过这个坑乍一看实在太像前端的锅了,但是又和前端完全没关系,是后端没处理好。但是也告诉了我一件事,身为一个前端应该对http请求,以及各个状态码都要有一定了解,而不是简单的1xx,2xx,3xx,4xx开头代表什么。这样下次碰到类似的问题就可以很快定位到原因了。]]></content>
      <tags>
        <tag>html5</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo配置]]></title>
    <url>%2F2017%2F10%2F25%2Fhexo-config%2F</url>
    <content type="text"><![CDATA[前言为什么选择hexo?以前也注册过博客园和csdn,不过没有经常逛与写的动力。后来学node的第一个demo就是用express搭一个博客。不过还是稍嫌烦了些。而hexo作为一个静态的博客,部署在github上,一切都简单很多。本来网上的教程已经很多了,在公司电脑上windows环境安装也很顺利。但是到家后用mac把项目clone下来运行碰到了一些坑,解决之后才有了自己记录下这个过程的想法。 配置环境NodeNode的话可以去官网下载安装 git关于git的安装使用廖雪峰老师的网站讲的也非常详细 github这个相信也不用我介绍了,全球最大的同性交友社区。创建和使用方式参照这里 安装hexo首先全局安装hexo: npm i -g hexo 如果是mac的话记住在前面加sudowindows下安装正常,但是在我的mac下报错了。不知道是不是每个人都会遇到。错误如下:这个问题卡了我很久,最后找到了解决方案,这里感谢这两篇博客。南不过远洋,李东浩 解决方法如下:npm config set user 0npm config set unsafe-perm true这时候再输入sudo npm i -g hexo,结果还是报错:看错误信息让我删除/usr/local/bin/hexo,可能是之前安装失败但创建路目录,找到删掉,然后重新执行sudo npm i -g hexo,安装成功。 接下来就是创建目路,初始化。 mkdir &lt;dir name&gt; cd &lt;dir name&gt; hexo init 到此安装步骤就完成了。 编译运行可以通过hexo new &lt;title&gt;新建文章,但是写好的文章怎么编译运行呢。 hexo g //生成静态页面 hexo server //启动本地服务,可以在http://localhost:4000访问 当然,生成静态页面之前最好hexo clean清理一下。不过如果每次编译运行都输入那么多命令还是挺麻烦的,这时候就可以借助npm的脚本来简化命令。找到根目录下的package.json,在scripts中添加如下内容: &quot;scripts&quot;: { &quot;dev&quot;: &quot;hexo clean &amp;&amp; hexo generate &amp;&amp; hexo server&quot; } 这样以后直接输入npm run dev就可以了。 部署到github在github建立好【your_user_name.github.io】的项目,配置好ssh key。然后在本地项目根目录打开_config.yml文件,拉倒最底下,修改如下: deploy: type: git repo: git@github.com:Guste/Guste.github.io.git //你的项目地址 branch: master 然后安装npm i hexo-deployer-git --save接下来和之前一样,hexo clean,hexo g,不过最后一步变成了hexo deploy,当然这也也比较比较繁琐,这时候又可以用到npm script了。打开package.json修改: &quot;scripts&quot;: { &quot;build&quot;: &quot;hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy&quot;, &quot;dev&quot;: &quot;hexo clean &amp;&amp; hexo generate &amp;&amp; hexo server&quot; } 这也以后直接 npm run build就好了。运行成功,打开http://guste.github.io/ (你对应的地址)就可以了。]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
