<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[jquery jsonp设置jsonpCallback遇到的坑]]></title>
    <url>%2F2018%2F04%2F24%2Fjquery-jsonp%E8%AE%BE%E7%BD%AEjsonpCallback%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[事情起因源自维护一份老的代码，其中跨域请求通过jsonp来获取数据，然后通过jquery的ajax方法来使用jsonp. 问题：代码中需要重复调用同一接口，但是接口在数据成功获取到的情况下，并未进入success回调，而是进入error，查看错误信息显示的是abort。 通过反复调试，最后发现$.ajax方法传入的option中有个参数叫jsonpCallback，其作用是指定callback回调时函数体的名称。这里写的是一个固定的值。试着修改通过给设定的jsonpCallback的值加入时间戳或者直接删除jsonpCallback，重复的请求jsonp就可以进入success了。虽然问题已经解决了，但其内在的逻辑仍需要探清。 分析：通过表象来看只是每次请求时jsonpCallback名称是否相同导致是否success，那么是什么原因呢？jsonp众所周知就是通过一个script标签来跨域请求目标服务器的对应接口数据，然后执行回调函数获得所需的data.所以按理说相同的回调函数名会影响得到其包裹的data吗？显然不会。那么可能就和jquery有关了。 jquery源码（好像贴的是zepto的，无所谓了。）我们找到与jsonp相关的部分 //options就是我们通过$.ajax传入的参数 $.ajaxJSONP = function(options, deferred){ if (!(&apos;type&apos; in options)) return $.ajax(options) //我们传入的jsonpCallback赋值给了_callbackName，若没传，则callbackName就是一个随机动态的字符串 var _callbackName = options.jsonpCallback, callbackName = ($.isFunction(_callbackName) ? _callbackName() : _callbackName) || (&apos;Zepto&apos; + (jsonpID++)), //生成一个script标签，用来请求数据 script = document.createElement(&apos;script&apos;), originalCallback = window[callbackName], responseData, //中断请求的方法 abort = function(errorType) { $(script).triggerHandler(&apos;error&apos;, errorType || &apos;abort&apos;) }, xhr = { abort: abort }, abortTimeout if (deferred) deferred.promise(xhr) //监听script标签的load和error事件 $(script).on(&apos;load error&apos;, function(e, errorType){ clearTimeout(abortTimeout) //移除script标签 $(script).off().remove() //若没有返回数据或者请求状态错误则抛出移除进入error,否则进入success if (e.type == &apos;error&apos; || !responseData) { ajaxError(null, errorType || &apos;error&apos;, xhr, options, deferred) } else { ajaxSuccess(responseData[0], xhr, options, deferred) } //这里获取外层的originalCallback,也就是callbackName window[callbackName] = originalCallback if (responseData &amp;&amp; $.isFunction(originalCallback)) originalCallback(responseData[0]) //清空返回的responseData originalCallback = responseData = undefined }) if (ajaxBeforeSend(xhr, options) === false) { abort(&apos;abort&apos;) return xhr } //以callbackName为变量名声明函数，绑到window上，其传参就是responseData window[callbackName] = function(){ responseData = arguments } //script标签的src即我们需要请求的接口的地址，将标签插入head script.src = options.url.replace(/\?(.+)=\?/, &apos;?$1=&apos; + callbackName) document.head.appendChild(script) //若超时则抛出异常。 if (options.timeout &gt; 0) abortTimeout = setTimeout(function(){ abort(&apos;timeout&apos;) }, options.timeout) return xhr } 这里我们模拟一下使用jquery发起一个jsonp的请求的过程，就可以得出结论了。 调用$.ajax方法 生成script标签 script标签上监听load和error事件 window上声明callbackName相同变量名的函数 script标签插入页面 回调执行拿到数据 下一个$.ajax方法执行 看上去是这样没错，但实际却有很大区别。当短时间内有很多相同callbackName的jsonp请求时，事实并不能如我们意。js中有异步的概念，并不是从头到尾按顺序依次生效的。 其中，第三步的事件监听是一个异步的操作，js中异步的任务会由对应的异步模块单独处理。处理完后其回调方法会被丢到一个任务队列当中，待主线程的所有同步任务执行完成后才会从队列中取出最先进入的任务执行作。就像setTimeout就是很典型的一个异步任务。值得一提的是vue中有个nextTick方法就利用了异步的特性，使得其可以在数据更改后，双向数据绑定修改dom，在dom重新渲染(这里不做讨论双向数据绑定具体实现)完成之后再执行nextTick里的回调。因为nextTick方法的实现之一就是timeout，所以会在任务队列的末尾插入回调任务.此时可以确保回调执行时页面dom早已更新完毕。 言归正传，那么我们分析下整个过程。 调用$.ajax方法 生成script标签 script标签上监听Load和error事件，对应的事件执行将扔到任务队列当中 script标签插入到页面当中，其请求过程是异步的，会被丢到任务队列，解析和执行过程是同步的，会产生阻塞。这里需要注意下，很多人弄不清其中的关系。网页加载过程中script标签是阻塞的，但阻塞的是后续的dom树的构建，其网络请求仍是异步的。 之前绑到window的回调执行，数据放到声明的responseData当中 下一个$.ajax方法调用，对应jquery里面的jsonp的方法重新初始化，且由于两次请求的callbackName名称相同，使得window上的该变量名的方法也重新赋值。上一个请求得到的responseData也成了undefined. 生成script标签发起异步的网络请求进入任务队列 此时主线程的同步任务已经执行完了。开始执行任务队列里上一个script标签onload触发的callback, 由于responseData已经成了undefinde，所以抛出异常，执行进入error当中。 最后我想说。。。还是早点把jquery扔了吧。。。]]></content>
      <tags>
        <tag>jquery</tag>
        <tag>任务队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[audio标签与206状态码]]></title>
    <url>%2F2017%2F10%2F25%2Faudio-and-206%2F</url>
    <content type="text"><![CDATA[前言在此之前从没能把这俩家伙联系到一起过,因为本身处理媒体资源的经历也比较少。事情的开头是这样的,下午妹纸突然发微信给我,说是碰到个很奇怪的问题。audio标签引用mp3资源,在页面初次加载时拖动进度条,鼠标释放后自己又跑回了0:00的初始位置。音频资源缓冲完毕后再刷新就可以随意拖动了。 实践从妹纸那拿到音频资源的地址,然后写了个demo试验: &lt;audio src=&quot;http://101.132.40.17:8080/tccrm2_saas_ws2/monitor/Miaow-07-Bubble.mp3&quot; controls=&quot;controls&quot;&gt;&lt;/audio&gt; 特意翻了下w3cschool,没有问题,但初次加载果然拖动后立马回到初始位置,等待资源缓冲完毕后可以随意拖动。清除缓存后再次打开又不行。再次打开w3cschool,翻看了其事件和相关api,仍旧没有头绪。使用原生js的currentTime手动修改当前位置,结果仍旧是直接回到0:00。头大。 搜索引擎网上搜索: audio标签拖拽进度条 一系列相关关键词,但是没找到任何有关系的结果。难道大家都没遇到过这个问题吗?于是我去stack overflow提问,英语虽渣但勉强把问题描述清楚了（外国朋友一定会觉得语法很奇怪）。过了一会儿有人回答了,因为我把上面的代码也复制进去了,对方回答说:首先你的提问和你的代码没有关系,其次已经有类似的问题我已经做出解答了。(汗,我特意先搜过有没有相关问题了,但奈何英语差加上可能关键词不对),于是跳转到对方给的链接,问题是为什么我的audio标签进度条不工作,下面只有一个回答。不过并没有讲解决方案而是提到了206状态码。206?我特意去搜了一下。表示该响应是表示客户端通过发送范围请求头Range抓取到了资源的部分数据,通常是用来: 学习http头和状态. 解决网路问题. 解决大文件下载问题. 解决CDN和原始HTTP服务器问题. 使用工具例如lftp,wget,telnet测试断电续传. 测试将一个大文件分割成多个部分同时下载. 可是和我的audio标签的问题又有什么关联呢?我仔细观察了下我的demo的网络请求,发现了点端倪。初次加载的时候响应的状态码是200,这时候控件是无法有效拖动的,即便缓冲成功。但是缓冲成功后再刷新页面,响应的状态码就成了206.貌似看到些曙光了,于是继续研究206状态。原来206请求是个范围请求,audio标签的src请求媒体资源时请求头会带上Range: bytes=0-,意思就是告诉服务器我要发起个范围请求,并指定想要的字节范围。服务器收到后响应,如果支持的话那么响应头会带上Content-Length和Accept-Ranges,这时候audio标签的进度条就可以随意拖动进度。如果服务器不支持,那么也不会报错,仍旧可以成功的返回200状态,但是音频资源只能从头不间断的播放到尾。 问题总结现在事情的脉络很清楚了,初次加载资源时,客户端向服务端发起了范围请求,服务端不支持（妥妥的后端的锅）,返回了个200状态码,音频照常播放,但是无法拖动进度。音频缓冲完毕后刷新页面,资源从缓存中读取,所以范围请求成功,返回206.进度条可以随意拖动。 感想最大的收获就是让我对从没关注过的206范围请求,及audio相关的细节有了一定了解。不过这个坑乍一看实在太像前端的锅了,但是又和前端完全没关系,是后端没处理好。但是也告诉了我一件事,身为一个前端应该对http请求,以及各个状态码都要有一定了解,而不是简单的1xx,2xx,3xx,4xx开头代表什么。这样下次碰到类似的问题就可以很快定位到原因了。]]></content>
      <tags>
        <tag>html5</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo配置]]></title>
    <url>%2F2017%2F10%2F25%2Fhexo-config%2F</url>
    <content type="text"><![CDATA[前言为什么选择hexo?以前也注册过博客园和csdn,不过没有经常逛与写的动力。后来学node的第一个demo就是用express搭一个博客。不过还是稍嫌烦了些。而hexo作为一个静态的博客,部署在github上,一切都简单很多。本来网上的教程已经很多了,在公司电脑上windows环境安装也很顺利。但是到家后用mac把项目clone下来运行碰到了一些坑,解决之后才有了自己记录下这个过程的想法。 配置环境NodeNode的话可以去官网下载安装 git关于git的安装使用廖雪峰老师的网站讲的也非常详细 github这个相信也不用我介绍了,全球最大的同性交友社区。创建和使用方式参照这里 安装hexo首先全局安装hexo: npm i -g hexo 如果是mac的话记住在前面加sudowindows下安装正常,但是在我的mac下报错了。不知道是不是每个人都会遇到。错误如下:这个问题卡了我很久,最后找到了解决方案,这里感谢这两篇博客。南不过远洋,李东浩 解决方法如下:npm config set user 0npm config set unsafe-perm true这时候再输入sudo npm i -g hexo,结果还是报错:看错误信息让我删除/usr/local/bin/hexo,可能是之前安装失败但创建路目录,找到删掉,然后重新执行sudo npm i -g hexo,安装成功。 接下来就是创建目路,初始化。 mkdir &lt;dir name&gt; cd &lt;dir name&gt; hexo init 到此安装步骤就完成了。 编译运行可以通过hexo new &lt;title&gt;新建文章,但是写好的文章怎么编译运行呢。 hexo g //生成静态页面 hexo server //启动本地服务,可以在http://localhost:4000访问 当然,生成静态页面之前最好hexo clean清理一下。不过如果每次编译运行都输入那么多命令还是挺麻烦的,这时候就可以借助npm的脚本来简化命令。找到根目录下的package.json,在scripts中添加如下内容: &quot;scripts&quot;: { &quot;dev&quot;: &quot;hexo clean &amp;&amp; hexo generate &amp;&amp; hexo server&quot; } 这样以后直接输入npm run dev就可以了。 部署到github在github建立好【your_user_name.github.io】的项目,配置好ssh key。然后在本地项目根目录打开_config.yml文件,拉倒最底下,修改如下: deploy: type: git repo: git@github.com:Guste/Guste.github.io.git //你的项目地址 branch: master 然后安装npm i hexo-deployer-git --save接下来和之前一样,hexo clean,hexo g,不过最后一步变成了hexo deploy,当然这也也比较比较繁琐,这时候又可以用到npm script了。打开package.json修改: &quot;scripts&quot;: { &quot;build&quot;: &quot;hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy&quot;, &quot;dev&quot;: &quot;hexo clean &amp;&amp; hexo generate &amp;&amp; hexo server&quot; } 这也以后直接 npm run build就好了。运行成功,打开http://guste.github.io/ (你对应的地址)就可以了。]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
